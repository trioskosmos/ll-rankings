<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Master Rankings Suite</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        :root {
            /* Premium Dark Theme */
            --bg: #0d1117;
            --card: #161b22;
            --border: #30363d;
            --pink: #db61a2;
            /* Softer premium pink */
            --green: #3fb950;
            --red: #f85149;
            --yellow: #d29922;
            --purple: #a371f7;
            --text: #c9d1d9;
            --muted: #8b949e;
            --font-size-base: 16px;
            /* Reset to standard accessible size */
        }

        /* ... Reset ... */

        body {
            font-family: 'Segoe UI', -apple-system, sans-serif;
            /* Cleaner font stack */
            background: var(--bg);
            color: var(--text);
            margin: 0;
            font-size: var(--font-size-base);
            min-height: 100vh;
            overflow-x: hidden;
            letter-spacing: 0.02em;
        }

        /* --- CONTROLS & HEADER --- */
        select {
            background: #21262d;
            /* Distinct background */
            color: #fff;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
        }

        /* Fix for invisible text in some browsers */
        option {
            background: var(--bg);
            color: var(--text);
        }

        /* --- LAYOUT --- */
        * {
            box-sizing: border-box;
        }

        header {
            background: var(--card);
            border-bottom: 1px solid var(--border);
            padding: 15px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        h1 {
            font-size: 18px;
            margin: 0;
            color: #fff;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .selector-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .selector-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .selector-wrapper label {
            font-size: 9px;
            text-transform: uppercase;
            color: var(--muted);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .nav {
            display: flex;
            gap: 8px;
            margin-left: auto;
            flex-wrap: wrap;
        }

        .nav-item {
            cursor: pointer;
            color: var(--muted);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 8px 14px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .nav-item:hover {
            color: var(--text);
            background: rgba(255, 255, 255, 0.05);
        }

        .nav-item.active {
            color: var(--pink);
            background: rgba(219, 97, 162, 0.1);
            border-color: var(--pink);
        }

        /* --- MAIN CONTENT --- */
        main {
            padding: 25px;
            padding-bottom: 100px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            transition: border-color 0.2s ease;
        }

        .card:hover {
            border-color: #444c56;
        }

        h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        /* --- TABLES --- */
        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: left;
            padding: 10px 8px;
            color: var(--muted);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border);
        }

        td {
            padding: 12px 8px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            font-size: 14px;
            vertical-align: middle;
        }

        tr:hover td {
            background: rgba(255, 255, 255, 0.02);
        }

        .col-rank {
            width: 50px;
            font-weight: 800;
            color: var(--pink);
            font-family: 'Consolas', monospace;
        }

        .col-metric {
            width: 80px;
            text-align: right;
            font-family: 'Consolas', monospace;
            font-weight: 600;
        }

        .col-fight {
            width: 160px;
            font-size: 11px;
            color: var(--muted);
            font-style: italic;
        }

        /* --- MATRIX --- */
        #matrix-scroll-wrapper {
            overflow-x: auto;
        }

        #c-matrix {
            display: grid;
            gap: 2px;
            margin-top: 10px;
            width: fit-content;
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 700;
            min-width: 50px;
        }

        .m-label {
            font-size: 10px;
            color: var(--muted);
            padding: 8px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- FOOTER --- */
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--card);
            border-top: 1px solid var(--border);
            padding: 12px 25px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }

        .footer-right {
            display: flex;
            gap: 10px;
        }

        .btn-footer {
            background: var(--bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-footer:hover {
            background: var(--border);
        }

        .comp-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
        }

        .comp-tab {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 700;
            color: var(--muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comp-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .comp-tab.active {
            background: var(--pink);
            color: #000;
        }

        .btn-submit-action {
            background: var(--pink);
            color: #000;
            border: none;
        }

        .btn-submit-action:hover {
            background: #e54d93;
        }

        #engine-log {
            font-size: 11px;
            font-family: 'Consolas', monospace;
            color: var(--muted);
        }

        .clickable-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .clickable-row:hover td {
            color: var(--pink) !important;
        }

        .axis-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        .axis-item:hover {
            border-color: var(--pink);
            background: rgba(219, 97, 162, 0.05);
        }

        .bar-bg {
            height: 18px;
            background: #21262d;
            border-radius: 4px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--pink) 0%, var(--purple) 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        /* --- DASHBOARD GRID --- */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 18px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 18px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 140px;
            transition: all 0.2s ease;
        }

        .stat-card:hover {
            border-color: var(--pink);
            transform: translateY(-2px);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--pink);
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--muted);
            letter-spacing: 1px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 800;
            color: #fff;
            line-height: 1.2;
            margin-bottom: 4px;
        }

        .stat-sub {
            font-size: 13px;
            color: var(--pink);
            font-weight: 600;
            margin-top: auto;
        }

        /* --- SUBMISSION PAGE DESIGN --- */
        #submission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 17, 23, 0.98);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }

        .modal-card {
            width: 100%;
            max-width: 900px;
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 45px;
            position: relative;
            max-height: 95vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .close-btn {
            position: absolute;
            top: 25px;
            right: 25px;
            font-size: 36px;
            cursor: pointer;
            color: var(--muted);
            line-height: 1;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: var(--pink);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 800;
            color: var(--text);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-select {
            width: 100%;
            background: #1c2128;
            border: 2px solid var(--pink);
            border-radius: 12px;
            color: #fff;
            padding: 18px;
            font-size: 22px;
            font-weight: bold;
            outline: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 20px center;
            background-size: 20px;
        }

        .modal-input,
        .modal-textarea {
            width: 100%;
            background: #1c2128;
            border: 2px solid var(--border);
            border-radius: 12px;
            color: #fff;
            padding: 18px;
            font-size: 20px;
            outline: none;
            transition: border-color 0.2s;
        }

        .modal-input:focus,
        .modal-textarea:focus {
            border-color: var(--pink);
            box-shadow: 0 0 10px rgba(248, 82, 173, 0.2);
        }

        .modal-textarea {
            height: 350px;
            font-family: monospace;
            font-size: 16px;
            line-height: 1.5;
        }

        .submit-btn {
            background: var(--pink);
            color: #000;
            font-weight: 900;
            border: none;
            padding: 22px;
            border-radius: 12px;
            width: 100%;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 20px;
            letter-spacing: 1px;
            transition: transform 0.1s, opacity 0.2s;
        }

        .submit-btn:active {
            transform: scale(0.98);
        }

        .submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- USERS PAGE STYLES --- */
        .user-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
            gap: 20px;
        }

        .user-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .user-card:hover {
            border-color: var(--pink);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .user-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 20px;
            background: linear-gradient(135deg, rgba(219, 97, 162, 0.1) 0%, transparent 100%);
            border-bottom: 1px solid var(--border);
        }

        .user-name {
            font-size: 18px;
            font-weight: 800;
            color: var(--pink);
        }

        .song-count {
            font-size: 12px;
            color: var(--muted);
            font-family: monospace;
            background: var(--bg);
            padding: 4px 10px;
            border-radius: 20px;
        }

        .user-insights {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: var(--border);
            margin-bottom: 1px;
        }

        .insight-item {
            background: var(--card);
            padding: 12px 15px;
            font-size: 12px;
        }

        .insight-label {
            color: var(--muted);
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .insight-value {
            color: #fff;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .insight-value.green {
            color: var(--green);
        }

        .insight-value.yellow {
            color: var(--yellow);
        }

        .rankings-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
        }

        .rankings-list::-webkit-scrollbar {
            width: 6px;
        }

        .rankings-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .rankings-list::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .rankings-list::-webkit-scrollbar-thumb:hover {
            background: var(--pink);
        }

        .rank-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: var(--bg);
            border-radius: 6px;
            transition: all 0.15s ease;
        }

        .rank-item:hover {
            background: #21262d;
            padding-left: 14px;
        }

        .rank-item.top-3 {
            background: linear-gradient(90deg, rgba(219, 97, 162, 0.15) 0%, var(--bg) 100%);
        }

        .rank-number {
            font-size: 14px;
            font-weight: 800;
            color: var(--pink);
            min-width: 35px;
            text-align: right;
            font-family: 'Consolas', monospace;
        }

        .rank-number.gold {
            color: #ffd700;
        }

        .rank-number.silver {
            color: #c0c0c0;
        }

        .rank-number.bronze {
            color: #cd7f32;
        }

        .song-name {
            flex: 1;
            font-size: 13px;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <header>
        <div class="header-left">
            <h1>Rankings Suite</h1>
            <div class="selector-group">
                <div class="selector-wrapper">
                    <label>Franchise</label>
                    <select id="view-franchise" onchange="changeFranchiseView()">
                        <option value="liella">Liella</option>
                        <option value="aqours">Aqours</option>
                        <option value="u's">u's</option>
                        <option value="nijigasaki">Nijigasaki</option>
                        <option value="hasunosora">Hasunosora</option>
                    </select>
                </div>
                <div class="selector-wrapper">
                    <label>View</label>
                    <select id="view-subgroup" onchange="changeSubgroupView()"></select>
                </div>
                <button id="mode-toggle" onclick="toggleAdvancedMode()"
                    style="padding:6px 12px; font-size:10px; font-weight:bold; text-transform:uppercase; background:transparent; border:1px solid var(--border); color:var(--muted); border-radius:4px; cursor:pointer;">
                    Basic Mode
                </button>
            </div>
        </div>
        <div class="nav">
            <div class="nav-item active" id="btn-dash" onclick="tab('dash')">Dashboard</div>
            <div class="nav-item" id="btn-leader" onclick="tab('leader')">Rankings</div>
            <div class="nav-item" id="btn-tiers" onclick="tab('tiers')">Tiers</div>
            <div class="nav-item" id="btn-aff" onclick="tab('aff')">Affinity</div>
            <div class="nav-item" id="btn-subranks" onclick="tab('subranks')">Subunits</div>
            <div class="nav-item" id="btn-more" onclick="tab('more')">Analysis</div>
            <div class="nav-item" id="btn-opps" onclick="tab('opps')">Divergence / Rivals</div>
            <div class="nav-item" id="btn-constellation" onclick="tab('constellation')">Constellation</div>
            <div class="nav-item" id="btn-oshi" onclick="tab('oshi')">Oshi Detector</div>
            <div class="nav-item" id="btn-spice" onclick="tab('spice')">Spice</div>
            <div class="nav-item" id="btn-users" onclick="tab('users')">Users</div>
        </div>
    </header>

    <main>
        <!-- DASHBOARD VIEW -->
        <div id="view-dash" class="grid">
            <div class="dashboard-grid" id="dashboard-stats">
                <div class="stat-card">
                    <div class="stat-label">👑 Current #1</div>
                    <div class="stat-value" id="d-top-song">Loading...</div>
                    <div class="stat-sub" id="d-top-score">-- avg rank</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">🔥 Most Controversial</div>
                    <div class="stat-value" id="d-cont-song">Loading...</div>
                    <div class="stat-sub" id="d-cont-score">High Disagreement</div>
                </div>
                <div class="stat-card" id="card-spice" style="transition: transform 0.2s;">
                    <div class="stat-label">🌶️ Spiciest User</div>
                    <div class="stat-value" id="d-spice-user">Loading...</div>
                    <div class="stat-sub" id="d-spice-val">-- Spice</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">😴 Sleeper Hit</div>
                    <div class="stat-value" id="d-sleep-song">Loading...</div>
                    <div class="stat-sub" id="d-sleep-user">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">🤝 Most Agreed</div>
                    <div class="stat-value" id="d-agreed-song">Loading...</div>
                    <div class="stat-sub" id="d-agreed-score">Low Controversy</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">📊 Total Songs</div>
                    <div class="stat-value" id="d-total-songs">--</div>
                    <div class="stat-sub">In current view</div>
                </div>
            </div>

            <div class="dashboard-grid">
                <div class="card">
                    <h3>🏆 Top 5 Songs</h3>
                    <div class="table-container" id="c-dash-top5"></div>
                </div>
                <div class="card">
                    <h3>📉 Bottom 5 Songs</h3>
                    <div class="table-container" id="c-dash-bottom5"></div>
                </div>
            </div>


        </div>

        <!-- FULL RANKINGS VIEW -->
        <div id="view-leader" class="card hidden">
            <h3>Full Community Consensus</h3>
            <p style="font-size:11px; color:var(--muted); margin-bottom:15px;">Click any song to see ranking
                distribution</p>
            <div class="table-container" id="c-leaderboard"></div>
        </div>

        <!-- SONG DISTRIBUTION MODAL -->
        <div id="song-modal" class="hidden"
            style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:1000; display:flex; align-items:center; justify-content:center;"
            onclick="closeSongModal(event)">
            <div class="card"
                style="max-width:900px; width:95%; max-height:85vh; padding:0; display:flex; flex-direction:column;"
                onclick="event.stopPropagation()">
                <div
                    style="display:flex; justify-content:space-between; align-items:center; padding:20px 25px; border-bottom:1px solid var(--border);">
                    <h3 id="song-modal-title" style="margin:0; border:none; font-size:18px; color:var(--pink);">Song
                        Distribution</h3>
                    <button onclick="closeSongModal()"
                        style="background:none; border:none; color:var(--muted); font-size:24px; cursor:pointer;">&times;</button>
                </div>
                <div id="song-modal-content" style="padding:25px; overflow-y:auto; flex:1;"></div>
            </div>
        </div>
        </div>

        <!-- VIEW: SUBUNIT RANKINGS -->
        <div id="view-subranks" class="hidden">
            <div class="card">
                <h3>🏆 Subunit Leaderboard</h3>
                <div class="table-container">
                    <table id="t-subranks">
                        <thead>
                            <tr>
                                <th style="width:50px;">Rank</th>
                                <th style="width:100px;">Type</th>
                                <th>Subgroup Name</th>
                                <th style="text-align:right;">Songs</th>
                                <th style="text-align:right;">Avg Global Rank</th>
                                <th style="text-align:right;">Top Song</th>
                            </tr>
                        </thead>
                        <tbody id="tbody-subranks"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- ANALYSIS VIEW -->
        <div id="view-more" class="hidden"
            style="display:grid; grid-template-columns:repeat(auto-fit, minmax(280px, 1fr)); gap:20px; align-items:start;">
            <!-- Row 1: The "Personal Opinions" & "Controversy" Line -->
            <div class="card">
                <h3 onclick="showMetricExplanation('disputed')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Most Disputed ℹ️</h3>
                <div class="table-container" id="c-disputed"></div>
            </div>
            <div class="card">
                <h3 onclick="showMetricExplanation('sleeper')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Sleeper Picks ℹ️</h3>
                <div class="table-container" id="c-sleeper"></div>
            </div>
            <div class="card">
                <h3 onclick="showMetricExplanation('haters')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Hot Takes ℹ️</h3>
                <div class="table-container" id="c-haters"></div>
            </div>
            <div class="card">
                <h3 onclick="showMetricExplanation('controversy')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Controversial Tracks ℹ️</h3>
                <div class="table-container" id="c-controversy"></div>
            </div>

            <!-- Row 2: Community Trends -->
            <div class="card" style="grid-column: span 2;">
                <h3 onclick="showMetricExplanation('consistent')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Consistent Tracks (Consensus) ℹ️</h3>
                <div class="table-container" id="c-consistent"></div>
            </div>

            <!-- Row 3: Universal (Full Span) -->
            <div class="card" style="grid-column: 1 / -1;">
                <h3>Top/Bottom 10</h3>
                <div class="table-container" id="c-universal"></div>
            </div>

            <!-- Row 4: Secondary Metrics -->
            <div class="card" style="grid-column: span 2;">
                <h3 onclick="showMetricExplanation('subunits')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Subunit Power Rankings ℹ️</h3>
                <div class="table-container" id="c-subunits"></div>
            </div>
            <div class="card" style="grid-column: span 2;">
                <h3 onclick="showMetricExplanation('outliers')"
                    style="cursor:help; border-bottom:1px dashed var(--muted);">Outliers (Spice Meter) ℹ️</h3>
                <div class="table-container" id="c-outliers"></div>
            </div>
        </div>

        <!-- VIEW: TIERS -->
        <div id="view-tiers" class="grid hidden">
            <div class="card" style="grid-column: 1 / -1;">
                <h3>Tier Distribution</h3>
                <p style="font-size:12px; color:var(--muted); margin-top:-10px; margin-bottom:15px;">Songs categorized
                    by percentile ranking. Hover over dots to see song names, hover over song names to highlight dots.
                </p>
                <!-- Horizontal bar showing tier distribution -->
                <div id="c-tier-bar"
                    style="height:40px; border-radius:8px; overflow:hidden; display:flex; margin-bottom:20px; background:var(--bg); border:1px solid var(--border);">
                </div>
                <!-- Dot chart canvas -->
                <div
                    style="position:relative; height:150px; margin-bottom:20px; background:var(--bg); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
                    <canvas id="c-tier-dots" style="width:100%; height:100%;"></canvas>
                    <div id="c-tier-tooltip"
                        style="position:absolute; display:none; background:var(--card); border:1px solid var(--border); border-radius:6px; padding:8px 12px; font-size:11px; pointer-events:none; z-index:100; box-shadow:0 4px 12px rgba(0,0,0,0.3);">
                    </div>
                </div>
                <!-- Song lists per tier -->
                <div id="c-tier-lists" class="grid"
                    style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:15px;"></div>
            </div>
        </div>

        <!-- VIEW: AFFINITY -->
        <div id="view-aff" class="grid hidden">
            <div class="card" style="grid-column: 1 / -1;">
                <h3>Subgroup Affinity (Bias)</h3>
                <p style="font-size:12px; color:var(--muted); margin-top:-10px; margin-bottom:20px;">Identifying songs
                    that this specific subgroup loves/hates disproportionately compared to the Global Average.</p>
                <div id="c-affinity"></div>
            </div>
            <div class="card">
                <h3>Unique Favorites</h3>
                <p style="font-size:12px; color:var(--muted); margin-top:-10px; margin-bottom:20px;">Songs ranked
                    significantly higher by this group than any other group.</p>
                <div id="c-unique-favs"></div>
            </div>
        </div>

        <!-- DIVERGENCE VIEW -->
        <div id="view-opps" class="card hidden">
            <h3>User Divergence & Head-to-Head Matrix</h3>
            <p style="font-size:12px; color:var(--muted); margin-top:-10px; margin-bottom:15px;">
                The lower the percentage, the more similar the taste. Click any cell to see a detailed
                <b>Head-to-Head</b> comparison.
            </p>
            <div id="matrix-scroll-wrapper">
                <div id="c-matrix"></div>
            </div>
        </div>

        <!-- SPICE VIEW -->
        <div id="view-spice" class="card hidden">
            <h3>Global Spice Breakdown</h3>
            <div id="c-spice"></div>
        </div>

        <!-- VIEW: CONSTELLATION -->
        <div id="view-constellation" class="card hidden">
            <h3 style="border:none; margin-bottom:10px; text-align:center;">🌌 Taste Constellation</h3>
            <div style="font-size:12px; color:var(--muted); margin-bottom:15px; text-align:center;"
                id="constellation-desc">
                Visualizing <span id="constellation-dims">147-dimensional</span> taste differences in <span
                    id="constellation-mode-text">2D space</span>.
                <button id="toggle-3d" onclick="toggle3D()"
                    style="margin-left:10px; padding:4px 10px; font-size:10px; font-weight:bold; vertical-align:middle; background:transparent; border:1px solid var(--pink); color:var(--pink); border-radius:4px; cursor:pointer; text-transform:uppercase;">Switch
                    to 3D</button>
                <button id="toggle-zoom" onclick="toggleConstellationZoom()"
                    style="margin-left:5px; padding:4px 10px; font-size:10px; font-weight:bold; vertical-align:middle; background:transparent; border:1px solid var(--muted); color:var(--muted); border-radius:4px; cursor:pointer; text-transform:uppercase;">📏
                    Fit to Limit</button>
            </div>

            <canvas id="taste-canvas"
                style="width:100%; height:600px; background: radial-gradient(circle at center, #1b2028 0%, #0d1117 100%); border-radius:12px; border:1px solid var(--border); margin-bottom:20px;"></canvas>

            <!-- DIVERGENCE RANKINGS -->
            <div id="constellation-rankings"
                style="display:grid; grid-template-columns: 1fr 2fr; gap:20px; margin-bottom:30px;">
                <!-- Dataset Stats -->
                <div class="card" style="padding:20px;">
                    <h4
                        style="margin:0 0 15px 0; color:var(--pink); font-size:13px; text-transform:uppercase; letter-spacing:1px; display:flex; justify-content:space-between; align-items:center;">
                        Dataset Bounds
                        <span onclick="showMetricsHelp()"
                            style="font-size:10px; cursor:pointer; text-transform:none; opacity:0.8; border-bottom:1px dotted var(--pink);">(
                            ℹ️ Metrics Guide )</span>
                    </h4>
                    <div id="constellation-stats" style="font-size:12px; color:var(--muted);">
                        <div style="display:grid; gap:10px;">
                            <div
                                style="display:flex; justify-content:space-between; padding:8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                                <span>Max |PC1|:</span>
                                <span id="stat-max-pc1" style="font-family:monospace; color:#fff;">--</span>
                            </div>
                            <div
                                style="display:flex; justify-content:space-between; padding:8px; background:rgba(255,255,255,0.03); border-radius:6px;">
                                <span>Max |PC2|:</span>
                                <span id="stat-max-pc2" style="font-family:monospace; color:#fff;">--</span>
                            </div>
                            <div
                                style="display:flex; justify-content:space-between; padding:8px; background:rgba(219,97,162,0.1); border-radius:6px; border:1px solid rgba(219,97,162,0.3);">
                                <span style="color:var(--pink);">Max Magnitude:</span>
                                <span id="stat-max-mag"
                                    style="font-family:monospace; color:var(--pink); font-weight:bold;">--</span>
                            </div>
                        </div>
                        <div style="margin-top:15px; font-size:10px; line-height:1.5; color:rgba(255,255,255,0.4);">
                            <b>Dataset Bounds:</b> The observed max vs. the theoretical limit (N/√3).
                            Magnitude is the raw RMS distance from the consensus center. Values close to the limit
                            indicate extreme polarization.
                        </div>
                    </div>
                </div>

                <!-- User Rankings by Magnitude -->
                <div class="card" style="padding:20px;">
                    <h4
                        style="margin:0 0 15px 0; color:var(--pink); font-size:13px; text-transform:uppercase; letter-spacing:1px;">
                        Users by Divergence <span
                            style="font-weight:400; text-transform:none; font-size:11px; color:var(--muted);">(distance
                            from center)</span>
                    </h4>
                    <div id="constellation-user-rankings" style="max-height:200px; overflow-y:auto; font-size:12px;">
                        <div style="color:var(--muted); text-align:center; padding:20px;">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- LAYMAN EXPLANATION -->
            <div
                style="background:rgba(255,255,255,0.03); border-radius:12px; padding:25px; border:1px solid var(--border);">
                <h4 style="margin-top:0; color:var(--pink);">How to read this graph</h4>
                <p style="font-size:14px; color:#ccc; line-height:1.6; margin-bottom:20px;">
                    This map visualizes the "Social Geography" of taste.
                    <b>Distance = Disagreement</b>. The further apart two users are, the more they disagree on
                    rankings.
                </p>

                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:25px;">
                    <!-- Concept 1: The Main Divide -->
                    <!-- Concept 1: The Main Divide -->
                    <div>
                        <strong
                            style="color:#fff; display:block; margin-bottom:8px; border-bottom:1px solid var(--pink); padding-bottom:5px;">1.
                            The Main Divide (X-Axis)</strong>
                        <p style="font-size:13px; color:var(--muted); margin:0;">
                            This line represents the <b>single biggest difference</b> in opinion across the whole
                            group.
                            <br><br>
                            <b style="color:var(--pink); cursor:pointer;">Click the "X" Label</b> on the graph to
                            see exactly which songs are causing this split.
                            (Usually, people on the left love a certain style, while people on the right prefer
                            another).
                        </p>
                    </div>

                    <!-- Concept 2: The Nuance -->
                    <div>
                        <strong
                            style="color:#fff; display:block; margin-bottom:8px; border-bottom:1px solid var(--pink); padding-bottom:5px;">2.
                            The Nuance (Y-Axis)</strong>
                        <p style="font-size:13px; color:var(--muted); margin:0;">
                            This difference distinguishes people who might agree on the big stuff but disagree on
                            specific details.
                            <br><br>
                            <b style="color:var(--pink); cursor:pointer;">Click the "Y" Label</b> to see the songs
                            driving these finer distinctions.
                        </p>
                    </div>

                    <!-- Concept 3: The Layout -->
                    <div>
                        <strong
                            style="color:#fff; display:block; margin-bottom:8px; border-bottom:1px solid var(--pink); padding-bottom:5px;">3.
                            The Layout</strong>
                        <p style="font-size:13px; color:var(--muted); margin:0;">
                            <b>Distance &approx; Disagreement</b>.<br>
                            Users close together typically share very similar tastes. Users far apart rarely agree.
                            Look for clusters!
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: OSHI DETECTOR -->
        <div id="view-oshi" class="card hidden">
            <h3 style="border:none; margin-bottom:10px; text-align: center;">💖 Oshi Detector</h3>
            <div style="font-size:12px; color:var(--muted); margin-bottom:15px; text-align: center;">Who do you
                <i>really</i> love the most? (Based on average rank)
            </div>
            <div style="display:flex; gap:10px; align-items:center; justify-content:center; margin-bottom:15px;">
                <select id="bias-user" onchange="analyzeBias()"
                    style="width:200px; padding:10px; background:var(--card); border:1px solid var(--border); color:#fff; border-radius:6px;"></select>
            </div>
            <div id="bias-results" class="grid"
                style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:15px;"></div>
        </div>

        <script>

        </script>

        <!-- USERS VIEW -->
        <div id="view-users" class="hidden">
            <div id="users-stats-container"></div>
            <div id="users-content">
                <div style="text-align: center; padding: 80px 20px; font-size: 18px; color: var(--muted);">
                    Loading user rankings...
                </div>
            </div>
        </div>
    </main>

    <!-- UPDATED SUBMISSION OVERLAY -->
    <div id="submission-overlay">
        <div class="modal-card">
            <span class="close-btn" onclick="toggleSubmission(false)">&times;</span>
            <h3 style="font-size: 24px; margin-bottom: 30px; border:none;">Rankings Submission</h3>

            <div class="form-group">
                <label>1. Select Franchise</label>
                <select id="sub-franchise" class="modal-select">
                    <option value="liella">Liella</option>
                    <option value="aqours">Aqours</option>
                    <option value="u's">u's</option>
                    <option value="nijigasaki">Nijigasaki</option>
                    <option value="hasunosora">Hasunosora</option>
                </select>
            </div>

            <div class="form-group">
                <label>2. Your Name</label>
                <input type="text" id="in-user" class="modal-input" placeholder="Username">
            </div>

            <div class="form-group">
                <label>3. Ranked List (Format: 1. Song - Artist)</label>
                <textarea id="in-list" class="modal-textarea"
                    placeholder="1. Starlight Prologue - Liella!&#10;2. 始まりは君の空 - Liella!"></textarea>
            </div>

            <button class="submit-btn" id="submit-btn-real" onclick="postSubmission()">Post My Rankings</button>
            <div id="submit-log" style="margin-top:20px; font-size:16px;"></div>
        </div>
    </div>

    <footer>
        <div class="footer-left">
            <div id="engine-log">READY</div>
        </div>
        <div class="footer-right">
            <button class="btn-footer" onclick="recompute()">Recompute</button>
            <button class="btn-footer btn-submit-action" onclick="toggleSubmission(true)">Submit</button>
        </div>
    </footer>

    <script>
        // Use var to avoid redeclaration errors if app.js also loads
        var API = "/api/v1";
        var activeTab = activeTab || 'dash';
        var allSubgroups = allSubgroups || [];

        // Data cache to prevent redundant API calls
        var dataCache = dataCache || { key: '', ranks: null, cont: null, takes: null, spice: null, loaded: false };

        // Basic/Advanced Mode Toggle
        window.advancedMode = false;
        function toggleAdvancedMode() {
            window.advancedMode = !window.advancedMode;
            const btn = document.getElementById('mode-toggle');
            if (window.advancedMode) {
                btn.innerHTML = 'Advanced Mode';
                btn.style.background = 'var(--pink)';
                btn.style.color = '#000';
                btn.style.borderColor = 'var(--pink)';
            } else {
                btn.innerHTML = 'Basic Mode';
                btn.style.background = 'transparent';
                btn.style.color = 'var(--muted)';
                btn.style.borderColor = 'var(--border)';
            }
            // Re-render current tab with new limits
            if (dataCache.loaded) {
                renderCurrentTab();
            }
        }

        // Helper to get list limit based on mode
        function getLimit(basic, advanced) {
            return window.advancedMode ? advanced : basic;
        }

        async function init() {
            await fetchMasterSubgroups();
            tab('dash'); // Force dashboard view logic on startup
        }

        async function fetchMasterSubgroups() {
            const franchises = ["liella", "aqours", "u's", "nijigasaki", "hasunosora"];
            const results = await Promise.all(franchises.map(f => fetch(`${API}/subgroups?franchise=${f}`).then(r => r.json()).catch(() => [])));
            allSubgroups = results.flat();
            updateSubgroupDropdown();
        }

        function updateSubgroupDropdown() {
            const f = document.getElementById('view-franchise').value, sel = document.getElementById("view-subgroup");
            const filtered = allSubgroups.filter(sg => sg.franchise === f);

            // Categorize
            const groups = {
                "Main": [],
                "Subunits": [],
                "Solos": [],
                "Other": []
            };

            filtered.forEach(s => {
                if (s.name === "All Songs" || s.name === "Group Songs" || s.name === "Singles") {
                    groups["Main"].push(s);
                } else if (s.name.includes("Solos")) {
                    groups["Solos"].push(s);
                } else if (s.is_subunit) {
                    groups["Subunits"].push(s);
                } else {
                    groups["Other"].push(s);
                }
            });

            // Sort within groups
            Object.values(groups).forEach(g => g.sort((a, b) => a.name.localeCompare(b.name)));
            // Ensure All Songs is first in Main
            groups["Main"].sort((a, b) => (a.name === "All Songs" ? -1 : b.name === "All Songs" ? 1 : 0));

            let html = "";
            const cats = ["Main", "Subunits", "Solos", "Other"];

            cats.forEach(c => {
                if (groups[c].length > 0) {
                    const label = c === "Main" ? "General" : c; // Renaming Main to General for display
                    html += `<optgroup label="${label}">`;
                    html += groups[c].map(s => `<option value="${s.name}">${s.name} (${s.song_count})</option>`).join("");
                    html += `</optgroup>`;
                }
            });

            sel.innerHTML = html;

            // Auto-select All Songs or first available
            if (filtered.some(s => s.name === "All Songs")) sel.value = "All Songs";
            else if (filtered.length > 0) sel.selectedIndex = 0;
        }

        function changeFranchiseView() {
            dataCache = { key: '', ranks: null, cont: null, takes: null, spice: null, loaded: false }; // Clear cache
            wipeUI();
            updateSubgroupDropdown();
            syncData(true); // Force fetch
        }

        function changeSubgroupView() {
            dataCache = { key: '', ranks: null, cont: null, takes: null, spice: null, loaded: false }; // Clear cache
            wipeUI();
            syncData(true); // Force fetch
        }

        function wipeUI() {
            const ids = ['c-leaderboard', 'c-universal', 'c-disputed', 'c-subunits', 'c-controversy', 'c-sleeper', 'c-consistent', 'c-outliers', 'c-matrix', 'c-spice', 'c-dash-top5', 'c-dash-bottom5', 'duel-disputes', 'match-results', 'users-content'];
            ids.forEach(id => { const el = document.getElementById(id); if (el) el.innerHTML = "Refreshing..."; });
            ['d-top-song', 'd-cont-song', 'd-spice-user', 'd-sleep-song', 'd-agreed-song', 'd-total-songs'].forEach(id => document.getElementById(id).innerHTML = "...");
            const dr = document.getElementById('duel-results');
            if (dr) dr.classList.add('hidden');
            // Also clear users stats
            const us = document.getElementById('users-stats-container');
            if (us) us.innerHTML = '';
        }

        function tab(name) {
            activeTab = name;
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            document.getElementById(`btn-${name}`).classList.add('active');
            document.querySelectorAll('main > div').forEach(v => v.classList.add('hidden'));
            document.getElementById(`view-${name}`).classList.remove('hidden');
            syncData(false); // Don't force, use cache if available
        }

        async function syncData(forceFetch = false) {
            const sub = document.getElementById('view-subgroup').value, f = document.getElementById('view-franchise').value;
            if (!sub) return;

            // Priority fetch for Constellation to ensure immediate refresh
            if (activeTab === 'constellation') {
                try {
                    const res = await fetch(`${API}/analysis/divergence?franchise=${encodeURIComponent(f)}&subgroup=${encodeURIComponent(sub)}`);
                    const data = await res.json();
                    if (data && data.matrix) initConstellation(data);
                } catch (e) { console.error("Constellation load error:", e); }
                // Do not return, let standard data load proceed
            }

            const cacheKey = `${f}|${sub}`;
            let ranks, cont, takes, spice;

            // Check if we have cached data for this franchise/subgroup
            if (!forceFetch && dataCache.loaded && dataCache.key === cacheKey) {
                // Use cached data
                ranks = dataCache.ranks;
                cont = dataCache.cont;
                takes = dataCache.takes;
            } else {
                // Fetch fresh data with timeout
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout

                    [ranks, cont, takes] = await Promise.all([
                        fetch(`${API}/analysis/rankings?franchise=${f}&subgroup=${sub}`, { signal: controller.signal }).then(r => r.ok ? r.json() : null),
                        fetch(`${API}/analysis/controversy?franchise=${f}&subgroup=${sub}`, { signal: controller.signal }).then(r => r.ok ? r.json() : null),
                        fetch(`${API}/analysis/takes?franchise=${f}&subgroup=${sub}`, { signal: controller.signal }).then(r => r.ok ? r.json() : null)
                    ]);

                    clearTimeout(timeoutId);

                    const oldSpice = dataCache.spice; // Preserve spice if exists
                    dataCache = { key: cacheKey, ranks, cont, takes, spice: oldSpice, loaded: true };
                } catch (e) {
                    console.error('Fetch error:', e);
                    if (e.name === 'AbortError') {
                        const ids = ['c-leaderboard', 'c-universal', 'c-disputed', 'c-subunits', 'c-controversy', 'c-sleeper', 'c-consistent', 'c-outliers', 'c-matrix', 'c-spice', 'c-dash-top5', 'c-dash-bottom5'];
                        ids.forEach(id => { const el = document.getElementById(id); if (el) el.innerHTML = "Request timed out. Please refresh."; });
                    }
                    return;
                }
            }


            // Render tabs that don't depend on specific subgroup rankings first
            if (activeTab === 'spice' || activeTab === 'dash') fetchSpiceData();
            if (activeTab === 'oshi') { fetchUserList(); fetchBiasUserList(true); }
            if (activeTab === 'users') loadUsers();

            if (!ranks || !ranks.rankings) {
                // If on a rankings-dependent tab, we might want to show a message
                if (['leader', 'more', 'opps'].includes(activeTab)) {
                    console.warn("Rankings not available for this subgroup.");
                }
                return;
            }

            // Always update Dashboard Stats (if available) - Spice updated via its own fetch if needed
            updateDashboard(ranks.rankings, cont?.results, takes?.takes, null);

            // Always render full leaderboard data in background (so it's ready)
            renderLeaderboard(ranks.rankings);

            // Conditional rendering for active tabs to save DOM cycles
            if (activeTab === 'more') {
                renderUniversal(ranks.rankings, cont?.results || []); renderDisputed(takes?.takes || []);
                renderSubunitPopularity(ranks.rankings, cont?.results || [], f); renderControversy(cont?.results || []);
                renderConsistent(cont?.results || []); renderSleepers(takes?.takes || []);
                renderHaters(takes?.takes || []);
            }
            if (activeTab === 'opps') renderMatrix(sub, f);
            if (activeTab === 'tiers') renderTierStats(ranks.rankings, cont?.results || []);
            if (activeTab === 'aff') renderAffinity(ranks.rankings);
            if (activeTab === 'subranks') renderSubranks();

            // Render dashboard constellation when on dashboard tab
            if (activeTab === 'dash') {
                // (Constellation removed via user request)
            }
        }

        // Re-render current tab with cached data (used when mode changes)
        function renderCurrentTab() {
            if (!dataCache.loaded) return;
            const { ranks, cont, takes } = dataCache;
            const f = document.getElementById('view-franchise').value;
            const sub = document.getElementById('view-subgroup').value;

            if (ranks?.rankings) {
                updateDashboard(ranks.rankings, cont?.results, takes?.takes, null);
                renderLeaderboard(ranks.rankings);
            }
            if (activeTab === 'more' && ranks?.rankings) {
                renderUniversal(ranks.rankings, cont?.results || []);
                renderDisputed(takes?.takes || []);
                renderSubunitPopularity(ranks.rankings, cont?.results || [], f);
                renderControversy(cont?.results || []);
                renderConsistent(cont?.results || []);
                renderSleepers(takes?.takes || []);
                renderHaters(takes?.takes || []);
            }
            if (activeTab === 'opps') renderMatrix(sub, f);
            if (activeTab === 'opps') renderMatrix(sub, f);
            if (activeTab === 'subranks') renderSubranks();
            if (activeTab === 'spice' || activeTab === 'dash') fetchSpiceData();
            if (activeTab === 'constellation' || activeTab === 'oshi') fetchUserList();
        }


        function updateDashboard(ranks, cont, takes, spice) {
            // 1. Top Song
            if (ranks.length > 0) {
                const top = ranks[0];
                document.getElementById('d-top-song').innerHTML = `<span onclick="showSongDistribution('${top.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="song-link">${truncate(top.song_name, 22)}</span>`;
                document.getElementById('d-top-score').innerHTML = `${top.average} avg rank`;

                // Total songs count
                document.getElementById('d-total-songs').innerHTML = ranks.length;

                // Render Top 5 and Bottom 5
                renderDashTop5(ranks.slice(0, 5));
                renderDashBottom5(ranks.slice(-5).reverse());
            }

            // 2. Controversial
            if (cont && cont.length > 0) {
                const c = cont[0];
                document.getElementById('d-cont-song').innerHTML = `<span onclick="showSongDistribution('${c.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="song-link">${truncate(c.song_name, 22)}</span>`;
                document.getElementById('d-cont-score').innerHTML = `${c.controversy_score} score`;

                // Most Agreed (lowest controversy)
                const agreed = [...cont].sort((a, b) => a.controversy_score - b.controversy_score)[0];
                if (agreed) {
                    document.getElementById('d-agreed-song').innerHTML = `<span onclick="showSongDistribution('${agreed.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="song-link">${truncate(agreed.song_name, 22)}</span>`;
                    document.getElementById('d-agreed-score').innerHTML = `${agreed.controversy_score} score`;
                }
            }

            // 3. Spiciest User
            // This will now rely on the dataCache.spice which is fetched by fetchSpiceData
            if (dataCache.spice && dataCache.spice.results && dataCache.spice.results.length > 0) {
                const s = dataCache.spice.results[0];
                const card = document.getElementById('card-spice');
                if (card) {
                    card.onclick = () => showSpiceDetail(s.username);
                    card.style.cursor = 'pointer';
                    card.onmouseover = () => card.style.transform = 'scale(1.02)';
                    card.onmouseout = () => card.style.transform = 'scale(1)';
                }
                document.getElementById('d-spice-user').innerText = s.username;
                document.getElementById('d-spice-val').innerHTML = `${s.global_spice} spice`;
            }


            // 4. Sleeper Hit
            if (takes && takes.length > 0) {
                const sleeper = [...takes].sort((a, b) => a.score - b.score)[0];
                if (sleeper && sleeper.score < 0) {
                    document.getElementById('d-sleep-song').innerHTML = `<span onclick="showSongDistribution('${sleeper.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="song-link">${truncate(sleeper.song_name, 22)}</span>`;
                    document.getElementById('d-sleep-user').innerHTML = `Loved by ${sleeper.username}`;
                }
            }
        }

        function truncate(str, len) {
            return str.length > len ? str.substring(0, len) + '…' : str;
        }

        function renderDashTop5(ranks) {
            const el = document.getElementById('c-dash-top5');
            if (!el) return;
            el.innerHTML = `<table>` +
                ranks.map((s, i) => `
                    <tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row">
                        <td class="col-rank" style="color:${i === 0 ? '#ffd700' : i === 1 ? '#c0c0c0' : i === 2 ? '#cd7f32' : 'var(--pink)'}">#${i + 1}</td>
                        <td>${s.song_name}</td>
                        <td class="col-metric" style="color:var(--green)">${s.average}</td>
                    </tr>
                `).join('') + `</table>`;
        }

        function renderDashBottom5(ranks) {
            const el = document.getElementById('c-dash-bottom5');
            if (!el) return;
            const total = parseInt(document.getElementById('d-total-songs')?.innerHTML) || 100;
            el.innerHTML = `<table>` +
                ranks.map((s, i) => `
                    <tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row">
                        <td class="col-rank">#${total - i}</td>
                        <td>${s.song_name}</td>
                        <td class="col-metric" style="color:var(--red)">${s.average}</td>
                    </tr>
                `).join('') + `</table>`;
        }


        function renderLeaderboard(ranks) {
            // Always show full list in Rankings tab - clickable for distribution
            document.getElementById('c-leaderboard').innerHTML = `<table><colgroup><col class="col-rank"><col><col class="col-metric"><col class="col-metric"></colgroup><tr><th>#</th><th>Song Name</th><th>Avg</th><th>Pts</th></tr>` +
                ranks.map((s, i) => `<tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td class="col-rank">${i + 1}</td><td>${s.song_name}</td><td class="col-metric" style="color:var(--pink)">${s.average}</td><td class="col-metric">${s.points}</td></tr>`).join('') + `</table>`;
        }

        function closeSongModal(event) {
            if (event && event.target.id !== 'song-modal') return;
            document.getElementById('song-modal').classList.add('hidden');
            document.getElementById('song-modal').style.display = 'none';
        }

        async function showSongDistribution(songName) {
            const modal = document.getElementById('song-modal');
            const content = document.getElementById('song-modal-content');
            document.getElementById('song-modal-title').textContent = songName;
            modal.classList.remove('hidden');
            modal.style.display = 'flex';
            content.innerHTML = 'Loading distribution...';

            try {
                const f = document.getElementById('view-franchise').value;
                const sub = document.getElementById('view-subgroup').value;
                const res = await fetch(`${API}/analysis/divergence?franchise=${f}&subgroup=${sub}`);
                const data = await res.json();

                // Get song rankings from cached data or fetch
                const songId = Object.keys(data.song_names).find(id => data.song_names[id] === songName);
                if (!songId || !data.rankings[songId]) {
                    content.innerHTML = 'No ranking data available for this song.';
                    return;
                }

                const userRanks = data.rankings[songId];
                const users = Object.keys(userRanks).sort();
                const ranks = users.map(u => userRanks[u]);
                const mean = ranks.reduce((a, b) => a + b, 0) / ranks.length;
                const std = Math.sqrt(ranks.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / ranks.length);
                const minRank = 1;
                const maxRank = Object.keys(data.song_names).length;
                const range = (maxRank - minRank) || 1;

                // Create number line visualization
                const margin = 12; // Half dot width + padding
                const widthCalc = `(100% - ${margin * 2}px)`;

                content.innerHTML = `
                    <div style="margin-bottom:25px; text-align:center;">
                        <div style="display:inline-flex; gap:40px; font-size:15px;">
                            <div class="stat-item"><span style="color:var(--muted); font-size:11px; display:block; text-transform:uppercase;">Community Mean</span> <span style="font-weight:900; color:var(--pink); font-size:22px;">#${mean.toFixed(1)}</span></div>
                            <div class="stat-item"><span style="color:var(--muted); font-size:11px; display:block; text-transform:uppercase;">Std Deviation</span> <span style="font-weight:900; color:#fff; font-size:22px;">${std.toFixed(2)}</span></div>
                            <div class="stat-item"><span style="color:var(--muted); font-size:11px; display:block; text-transform:uppercase;">Total Voters</span> <span style="font-weight:900; color:#fff; font-size:22px;">${users.length}</span></div>
                        </div>
                    </div>
                    
                    <div style="position:relative; height:120px; border-radius:12px; margin:30px 0; border:1px solid var(--border); background:#0d1117; overflow:hidden;">
                        <!-- Selection Area Coloration (Full Width) -->
                         <div style="position:absolute; top:0; bottom:0; left:0; right:0; background:linear-gradient(90deg, rgba(63,185,80,0.1) 0%, rgba(219,97,162,0.1) 50%, rgba(248,81,73,0.1) 100%);"></div>

                        <!-- Main line -->
                        <div style="position:absolute; top:65px; left:${margin}px; right:${margin}px; height:2px; background:rgba(255,255,255,0.1);"></div>
                        
                        <!-- Mean marker -->
                        <div style="position:absolute; top:35px; left:calc(${margin}px + ${(mean - minRank) / range} * ${widthCalc}); transform:translateX(-50%); text-align:center; z-index:5;">
                            <div style="font-size:9px; color:var(--pink); font-weight:900; letter-spacing:1px; margin-bottom:2px;">AVG</div>
                            <div style="width:2px; height:50px; background:var(--pink); margin:0 auto; box-shadow:0 0 10px var(--pink);"></div>
                        </div>

                        <!-- Std dev range box -->
                        <div style="position:absolute; top:60px; height:10px; background:rgba(219,97,162,0.25); border:1px border var(--pink); border-radius:4px; 
                            left:calc(${margin}px + ${Math.max(0, (mean - std - minRank) / range)} * ${widthCalc}); 
                            width:calc(${(2 * std) / range} * ${widthCalc}); z-index:2;"></div>

                        <!-- User dots -->
                        ${users.map((user, i) => {
                    const rank = userRanks[user];
                    const pct = (rank - minRank) / range;
                    const color = rank < (mean - 2) ? 'var(--green)' : rank > (mean + 2) ? 'var(--red)' : 'var(--pink)';
                    return `<div title="${user}: #${rank}" 
                                style="position:absolute; top:58px; left:calc(${margin}px + ${pct} * ${widthCalc}); transform:translateX(-50%); 
                                width:16px; height:16px; background:${color}; border-radius:50%; border:2px solid #fff; cursor:pointer; z-index:${10 + i}; transition:all 0.2s;"
                                onmouseover="this.style.transform='translateX(-50%) scale(1.4)'; this.style.zIndex='100';"
                                onmouseout="this.style.transform='translateX(-50%) scale(1)'; this.style.zIndex='${10 + i}';"
                                onclick="event.stopPropagation(); window.showSpiceDetail('${user}')"></div>`;
                }).join('')}
                    </div>
                    <div style="display:flex; justify-content:space-between; margin-top:-10px; padding:0 ${margin}px;">
                         <div style="font-size:10px; color:var(--green); font-weight:800; text-transform:uppercase;">← High Rank (Love)</div>
                         <div style="font-size:10px; color:var(--red); font-weight:800; text-transform:uppercase;">Low Rank (Hate) →</div>
                    </div>

                    <div style="margin-top:35px;"><h4 style="margin-bottom:15px; font-size:14px; text-transform:uppercase; letter-spacing:1px; color:var(--muted);">Voter Breakdown</h4>
                        <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(140px, 1fr)); gap:10px;">
                            ${users.sort((a, b) => userRanks[a] - userRanks[b]).map(u => `
                                <div style="padding:10px 12px; background:var(--card); border:1px solid var(--border); border-radius:8px; display:flex; justify-content:space-between; align-items:center; cursor:pointer;" onclick="window.showSpiceDetail('${u}')">
                                    <span style="font-size:12px; font-weight:600;">${u.substring(0, 10)}</span>
                                    <span style="font-weight:900; color:var(--pink); font-family:monospace;">#${userRanks[u]}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            } catch (e) {
                console.error(e);
                content.innerHTML = 'Error loading distribution data.';
            }
        }

        async function showUserComparison(u1, u2) {
            const modal = document.getElementById('song-modal');
            const content = document.getElementById('song-modal-content');
            document.getElementById('song-modal-title').textContent = u1 === u2 ? 'Self-Reflection' : `${u1} vs ${u2}`;
            modal.classList.remove('hidden');
            modal.style.display = 'flex';

            if (u1 === u2) {
                content.innerHTML = `
                    <div style="text-align:center; padding:40px 20px; font-style:italic;">
                        <p style="font-size:18px; line-height:1.6; color:#fff;">
                            "Now you're tired of fighting (Fighting)<br>
                            Tired of fighting, fighting yourself"
                        </p>
                        <p style="font-size:14px; color:var(--muted); margin-top:15px;">— Matt Bellamy</p>
                    </div>
                `;
                return;
            }

            content.innerHTML = '<div style="padding:20px;">Loading comparison...</div>';

            try {
                const f = document.getElementById('view-franchise').value, sub = document.getElementById('view-subgroup').value;
                const r = await fetch(`${API}/analysis/head-to-head?franchise=${f}&subgroup=${sub}&user_a=${u1}&user_b=${u2}`);
                const data = await r.json();

                const n = data.diffs.length;
                // Calculate Raw RMS
                const rawRms = Math.sqrt(data.diffs.reduce((s, d) => s + Math.pow(d.diff, 2), 0) / n);
                // Normalize: Divide by (N-1) to get approx 0-1 range, then * 100 for percentage
                // Note: For random uniform rankings, expected absolute rank diff is N/3.
                // Standardizing against N-1 is a simple way to make it roughly scale-invariant.
                const rms = ((rawRms / Math.max(1, n - 1)) * 100).toFixed(1);

                window.__compData = { u1, u2, diffs: data.diffs, rms, rawRms: rawRms.toFixed(2), activeTab: 'dis' };
                renderCompModal();

            } catch (e) { console.error(e); content.innerHTML = '<div style="padding:20px;">Error loading comparison.</div>'; }
        }

        window.switchCompTab = (tab) => {
            if (!window.__compData) return;
            window.__compData.activeTab = tab;
            renderCompModal();
        };

        function renderCompModal() {
            const { u1, u2, diffs, rms, activeTab } = window.__compData;
            const content = document.getElementById('song-modal-content');

            let tableHtml = "";
            let sortedArr = [...diffs];

            if (activeTab === 'u1') {
                sortedArr.sort((a, b) => a.r1 - b.r1);
            } else if (activeTab === 'dis') {
                sortedArr.sort((a, b) => b.diff - a.diff);
            } else if (activeTab === 'agr') {
                sortedArr.sort((a, b) => a.diff - b.diff);
            }

            if (activeTab === 'math') {
                const sumSq = diffs.reduce((s, d) => s + Math.pow(d.diff, 2), 0);
                const n = diffs.length;
                const varVal = (sumSq / n).toFixed(2);
                const rawRms = Math.sqrt(sumSq / n).toFixed(2);

                tableHtml = `
                    <div style="border-left:3px solid var(--pink); padding-left:15px; margin-bottom:20px;">
                        <h4 style="font-size:13px; margin-bottom:10px; color:var(--pink);">Normalized Divergence Formula</h4>
                        <div style="font-family:'Consolas', monospace; font-size:12px; line-height:1.8; color:var(--muted);">
                            RMS = √(Σ(diff²)/N)<br>
                            <span style="color:#fff; font-weight:bold;">Metric = (RMS / (N-1)) × 100</span>
                        </div>
                    </div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:20px;">
                        <div class="card" style="padding:12px;">
                            <div style="font-size:10px; color:var(--muted); text-transform:uppercase; margin-bottom:5px;">Raw RMS</div>
                            <div style="font-size:20px; font-weight:900; color:#fff;">${rawRms}</div>
                        </div>
                        <div class="card" style="padding:12px;">
                            <div style="font-size:10px; color:var(--muted); text-transform:uppercase; margin-bottom:5px;">Avg Rank Diff</div>
                            <div style="font-size:20px; font-weight:900; color:#fff;">${rawRms}</div>
                        </div>
                        <div class="card" style="padding:12px; grid-column:span 2; background:var(--pink);">
                            <div style="font-size:10px; color:#000; text-transform:uppercase; margin-bottom:5px; opacity:0.7;">Final Normalized Score</div>
                            <div style="font-size:20px; font-weight:900; color:#000;">${rms}%</div>
                        </div>
                    </div>
                    <h4 style="font-size:13px; margin-bottom:10px;">
                        Complete Breakdown 
                        ${window.isAdvancedMode ? '' : '<span style="color:var(--muted); font-weight:400;">(Top 10 - Switch to Advanced for Full List)</span>'}
                    </h4>
                    <table style="margin-top:10px;">
                        <tr><th>Song</th><th>${u1}</th><th>${u2}</th><th>Diff</th><th>Diff²</th></tr>
                        ${diffs.sort((a, b) => b.diff - a.diff).slice(0, window.isAdvancedMode ? diffs.length : 10).map(d => `
                            <tr>
                                <td>${d.name}</td>
                                <td style="color:var(--muted)">#${d.r1}</td>
                                <td style="color:var(--muted)">#${d.r2}</td>
                                <td>${d.diff.toFixed(0)}</td>
                                <td style="color:var(--red)">${(d.diff * d.diff).toFixed(0)}</td>
                            </tr>
                        `).join('')}
                    </table>
                `;
            } else {
                tableHtml = `
                    <table>
                        <colgroup><col><col style="width:70px"><col style="width:70px"><col style="width:60px"></colgroup>
                        <tr><th>Song</th><th>${u1}</th><th>${u2}</th><th>Diff</th></tr>
                        ${sortedArr.map(d => `
                            <tr onclick="showSongDistribution('${d.name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row">
                                <td>${d.name}</td>
                                <td style="color:${d.r1 < d.r2 ? 'var(--green)' : 'var(--muted)'}">#${d.r1}</td>
                                <td style="color:${d.r2 < d.r1 ? 'var(--green)' : 'var(--muted)'}">#${d.r2}</td>
                                <td style="font-weight:bold; color:${d.diff > 20 ? 'var(--red)' : d.diff < 5 ? 'var(--green)' : 'var(--pink)'}">${Math.round(d.diff)}</td>
                            </tr>
                        `).join('')}
                    </table>
                `;
            }

            content.innerHTML = `
                <div style="text-align:center; padding:10px 0 20px 0; border-bottom:1px solid var(--border); margin-bottom:15px;">
                    <div style="font-size:32px; font-weight:900; color:var(--pink)">${rms}% <span style="font-size:12px; font-weight:600; color:var(--muted); vertical-align:middle;">DIVERGENCE</span></div>
                    
                    ${(() => {
                    let wins = 0, losses = 0, ties = 0;
                    diffs.forEach(d => {
                        if (d.r1 < d.r2) wins++;
                        else if (d.r1 > d.r2) losses++;
                        else ties++;
                    });
                    const total = wins + losses + ties;

                    return `
                        <div style="margin-top:15px; background:rgba(0,0,0,0.2); padding:10px; border-radius:8px;">
                            <div style="display:flex; justify-content:space-between; font-size:11px; font-weight:700; text-transform:uppercase; color:var(--muted); margin-bottom:5px;">
                                <span>${u1} Higher (${wins})</span>
                                <span>${u2} Higher (${losses})</span>
                            </div>
                            <div style="height:8px; display:flex; border-radius:4px; overflow:hidden;">
                                <div style="width:${(wins / total) * 100}%; background:var(--green);"></div>
                                <div style="width:${(ties / total) * 100}%; background:var(--muted);"></div>
                                <div style="width:${(losses / total) * 100}%; background:var(--pink);"></div>
                            </div>
                        </div>
                        `;
                })()}
                </div>

                <div class="comp-tabs">
            <div class="comp-tab ${activeTab === 'u1' ? 'active' : ''}" onclick="switchCompTab('u1')">${u1}'s Order</div>
            <div class="comp-tab ${activeTab === 'dis' ? 'active' : ''}" onclick="switchCompTab('dis')">Disagreements</div>
            <div class="comp-tab ${activeTab === 'agr' ? 'active' : ''}" onclick="switchCompTab('agr')">Agreements</div>
            <div class="comp-tab ${activeTab === 'math' ? 'active' : ''}" onclick="switchCompTab('math')">🧮 How It's Calculated</div>
        </div>
                <div style="margin-top:10px;">
                    ${tableHtml}
                </div>
            `;
        }

        function renderUniversal(ranks, controversy) {
            const limit = getLimit(10, Math.floor(ranks.length / 2));
            const top = ranks.slice(0, limit), btm = ranks.slice(-limit);
            const mapAgreement = (songName) => {
                const c = controversy.find(x => x.song_name === songName);
                return c ? Math.max(0, 100 - ((c.cv * c.avg_rank) * 2.5)).toFixed(1) : "0.0";
            };
            const rows = [...top, ...btm].map((s, i) => `<tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td class="col-rank" style="color:${i < limit ? 'var(--green)' : 'var(--red)'};">${i < limit ? 'TOP' : 'BTM'}</td><td>${s.song_name}</td><td class="col-metric" style="color:var(--pink);">${s.average}</td><td class="col-metric">${mapAgreement(s.song_name)}%</td></tr>`).join('');
            document.getElementById('c-universal').innerHTML = `<table><colgroup><col class="col-rank"><col><col class="col-metric"><col class="col-metric"></colgroup><thead><tr><th>Type</th><th>Song</th><th>Avg</th><th>Agr</th></tr></thead>${rows}</table>` +
                (!window.advancedMode && ranks.length > limit * 2 ? `<div style="padding:10px; text-align:center; font-size:11px; color:var(--muted); background:rgba(0,0,0,0.2); border-top:1px solid rgba(255,255,255,0.05);">Showing top/bottom ${limit} of ${ranks.length} songs. Enable Advanced Mode for full list.</div>` : '');
        }

        function renderDisputed(takes) {
            const limit = getLimit(10, 50);
            const songGroups = {};
            takes.forEach(t => { if (!songGroups[t.song_name]) songGroups[t.song_name] = []; songGroups[t.song_name].push(t); });
            const res = Object.keys(songGroups).map(name => {
                const g = songGroups[name].sort((a, b) => a.user_rank - b.user_rank);
                return { name, fight: `${g[0].username} (#${g[0].user_rank}) vs ${g[g.length - 1].username} (#${g[g.length - 1].user_rank})`, diff: Math.abs(g[g.length - 1].user_rank - g[0].user_rank) };
            }).sort((a, b) => b.diff - a.diff);

            const displayRes = res.slice(0, limit);

            document.getElementById('c-disputed').innerHTML = `<table><colgroup><col><col class="col-fight"><col class="col-metric"></colgroup>` +
                `<thead><tr><th style="text-align:left; padding-left:10px;">Song</th><th style="padding-left:10px;">Fight</th><th class="col-metric">Diff</th></tr></thead>` +
                displayRes.map(r => `<tr onclick="showSongDistribution('${r.name.replace(/'/g, "\\'")}')" style="cursor:pointer" class="clickable-row"><td style="padding:4px 10px;">${r.name}</td><td class="col-fight" style="padding-left:10px;">${r.fight}</td><td class="col-metric" style="color:var(--pink); font-weight:bold;">${r.diff}</td></tr>`).join('') +
                `</table>` +
                (!window.advancedMode && res.length > limit ? `<div style="padding:10px; text-align:center; font-size:11px; color:var(--muted); background:rgba(0,0,0,0.2); border-top:1px solid rgba(255,255,255,0.05);">Showing top ${limit} of ${res.length} disputes. Enable Advanced Mode for full list.</div>` : '');
        }

        function showMetricExplanation(type) {
            const modal = document.getElementById('song-modal');
            const content = document.getElementById('song-modal-content');
            const title = document.getElementById('song-modal-title');

            modal.classList.remove('hidden');
            modal.style.display = 'flex';

            const definitions = {
                disputed: {
                    title: "Most Disputed",
                    math: "Δ = Rank_Max - Rank_Min",
                    desc: "Calculates the raw gap between the person who loves the song the most vs. the person who hates it the most.",
                    use: "Identifies songs with the most extreme polarization. A high 'Fight' score means two users are essentially at war."
                },
                sleeper: {
                    title: "Sleeper Picks",
                    math: "Score = User_Rank - Avg_Rank (where < -15)",
                    desc: "Identifies songs that a specific user ranks significantly HIGHER (lower number) than the community average.",
                    use: "Finds your 'hidden gems'—songs you defend that everyone else ignores."
                },
                haters: {
                    title: "Hot Takes",
                    math: "Score = User_Rank - Avg_Rank (where > 15)",
                    desc: "Identifies songs that a specific user ranks significantly LOWER (higher number) than the community average.",
                    use: "Exposes your controversial dislikes. These are the popular songs you just don't get."
                },
                controversy: {
                    title: "Controversy Score",
                    math: "Score = StdDev * WeightingFactor",
                    desc: "A composite metric that measures the overall spread of opinion. <b>Div (Divergence)</b> in the table is the Coefficient of Variation (StdDev / Mean).",
                    use: "High Controversy = The community is confused or split. Low Controversy = Everyone agrees."
                },
                consistent: {
                    title: "Consistent Tracks",
                    math: "Score ≈ 0 (Lowest StdDev)",
                    desc: "Songs with the lowest standard deviation in rankings.",
                    use: "The 'Safe Bets'. These songs are universally agreed upon, whether they are good or bad. No one fights about them."
                },
                subunits: {
                    title: "Subunit Power",
                    math: "Avg = Σ(Song_Ranks) / Song_Count",
                    desc: "The geometric mean rank of all songs belonging to a specific subunit.",
                    use: "Objectively determines which subunit has the strongest overall discography according to the group."
                },
                outliers: {
                    title: "Spice Meter",
                    math: "Distance = Euclidean_Dist(User_Vector, Consensus_Vector)",
                    desc: "Measures how far a user's taste vector deviates from the 'average' taste vector of the group.",
                    use: "<b>High Spice</b> = Unique, contrarian taste.<br><b>Low Spice</b> = NPC energy (agrees with the majority)."
                }
            };

            const def = definitions[type];
            if (!def) return;

            title.textContent = def.title;
            content.innerHTML = `
                <div style="padding:10px;">
                    <div class="card" style="margin-bottom:20px; border-left:4px solid var(--pink);">
                        <h4 style="margin:0 0 10px 0; color:var(--pink);">The Math</h4>
                        <div style="font-family:'Consolas', monospace; font-size:14px; background:rgba(0,0,0,0.2); padding:10px; border-radius:6px;">
                            ${def.math}
                        </div>
                    </div>
                    
                    <div style="margin-bottom:20px;">
                        <h4 style="margin-bottom:10px;">What is this?</h4>
                        <p style="line-height:1.6; color:#ccc;">${def.desc}</p>
                    </div>

                    <div>
                        <h4 style="margin-bottom:10px;">Why use it?</h4>
                        <p style="line-height:1.6; color:#ccc;">${def.use}</p>
                    </div>
                </div>
            `;
        }



        function renderControversy(results) {
            const limit = getLimit(10, results.length);
            document.getElementById('c-controversy').innerHTML = `<table><colgroup><col><col class="col-metric"><col class="col-metric"></colgroup><tr><th>Song</th><th class="col-metric">Score</th><th class="col-metric">Div</th></tr>` + results.slice(0, limit).map(s => `<tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td>${s.song_name}</td><td class="col-metric" style="color:var(--pink)">${s.controversy_score}</td><td class="col-metric">${s.cv}</td></tr>`).join('') + `</table>`;
        }
        function renderConsistent(results) {
            const limit = getLimit(10, results.length);
            const sorted = [...results].sort((a, b) => a.controversy_score - b.controversy_score).slice(0, limit);
            document.getElementById('c-consistent').innerHTML = `<table><colgroup><col><col class="col-metric"><col class="col-metric"></colgroup><tr><th>Song</th><th class="col-metric">Score</th><th class="col-metric">Avg</th></tr>` + sorted.map(s => `<tr onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td>${s.song_name}</td><td class="col-metric" style="color:var(--pink)">${s.controversy_score}</td><td class="col-metric">${s.avg_rank}</td></tr>`).join('') + `</table>`;
        }
        function renderSleepers(takes) {
            const limit = getLimit(10, 50);
            const sleepers = takes.filter(t => t.score < -15).slice(0, limit);
            document.getElementById('c-sleeper').innerHTML = `<table><colgroup><col><col class="col-metric"><col class="col-metric"></colgroup><tr><th>Song</th><th class="col-metric">Lover</th><th class="col-metric">Gap</th></tr>` + sleepers.map(t => `<tr onclick="showSongDistribution('${t.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td>${t.song_name}</td><td class="col-metric">${t.username.substring(0, 8)} <span style="font-size:9px; opacity:0.7">#${t.user_rank}</span></td><td class="col-metric" style="color:var(--green)">${Math.abs(t.delta).toFixed(1)}</td></tr>`).join('') + `</table>`;
        }
        function renderHaters(takes) {
            const limit = getLimit(10, 50);
            const allHaters = takes.filter(t => t.score > 15);
            const displayHaters = allHaters.slice(0, limit);

            document.getElementById('c-haters').innerHTML = `<table><colgroup><col><col class="col-metric"><col class="col-metric"></colgroup>` +
                `<thead><tr><th style="padding-left:10px; text-align:left;">Song</th><th class="col-metric">Hater</th><th class="col-metric">Gap</th></tr></thead>` +
                displayHaters.map(t => `<tr onclick="showSongDistribution('${t.song_name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row"><td style="padding:4px 10px;">${t.song_name}</td><td class="col-metric">${t.username.substring(0, 8)} <span style="font-size:9px; opacity:0.7">#${t.user_rank}</span></td><td class="col-metric" style="color:var(--red); font-weight:bold;">${Math.abs(t.delta).toFixed(1)}</td></tr>`).join('') +
                `</table>` +
                (!window.advancedMode && allHaters.length > limit ? `<div style="padding:10px; text-align:center; font-size:11px; color:var(--muted); background:rgba(0,0,0,0.2); border-top:1px solid rgba(255,255,255,0.05);">Showing top ${limit} of ${allHaters.length} haters. Enable Advanced Mode for full list.</div>` : '');
        }

        async function fetchSpiceData(force = false) {
            const f = document.getElementById('view-franchise').value;
            const sub = document.getElementById('view-subgroup').value;
            const cacheKey = `spice_${f}`;

            // If we have cached data for this franchise, use it unless forced
            if (!force && dataCache.spice && dataCache.spiceKey === cacheKey) {
                renderSpice(dataCache.spice.results);
                return;
            }

            const el = document.getElementById('c-spice');
            if (el) el.innerHTML = '<div style="padding:60px; text-align:center;"><div class="spinner"></div><div style="margin-top:20px; color:var(--muted); letter-spacing:1px; font-size:12px; text-transform:uppercase;">Mixing the spice...</div></div>';

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 12000);

                const res = await fetch(`${API}/analysis/spice?franchise=${f}`, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!res.ok) throw new Error("API Error");

                const data = await res.json();

                // Update global cache
                dataCache.spice = data;
                dataCache.spiceKey = cacheKey;

                if (activeTab === 'spice') renderSpice(data.results);

                // Also update dashboard card if we are on dashboard
                if (activeTab === 'dash' && data.results.length > 0) {
                    const s = data.results[0];
                    const card = document.getElementById('card-spice');
                    if (card) {
                        // Ensure click handler is attached
                        card.onclick = () => window.showSpiceDetail(s.username);
                        card.title = "View Spice Details";
                    }
                    const valEl = document.getElementById('d-spice-val');
                    if (valEl) valEl.innerHTML = `${s.global_spice.toFixed(2)} spice`;
                    const subEl = document.getElementById('d-spice-user');
                    if (subEl) subEl.innerHTML = `<span style="font-weight:bold">${s.username}</span>`;
                }

            } catch (e) {
                console.error("Spice fetch error:", e);
                if (el) el.innerHTML = `<div style="padding:40px; text-align:center; color:var(--red);">
                    <div style="font-size:24px; margin-bottom:10px;">⚠️</div>
                    <div>Failed to load spice data.</div>
                    <button onclick="fetchSpiceData(true)" style="margin-top:15px; background:var(--card-bg); border:1px solid var(--border); color:var(--text); padding:8px 16px; border-radius:4px; cursor:pointer;">Retry Request</button>
                </div>`;
            }
        }

        function renderSpice(results) {
            const el = document.getElementById('c-spice');
            if (!el) return;

            if (!results || !results.length) {
                el.innerHTML = '<div style="padding:40px; color:var(--muted); text-align:center;">No spice data available for this franchise.</div>';
                return;
            }

            const sub = document.getElementById('view-subgroup').value;
            const isAll = sub === 'All Songs';
            const showAdvanced = window.advancedMode;

            // Header with Refresh Button
            const headerHtml = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                    <div>
                        <h3 style="margin:0; font-size:18px; color:var(--pink);">🔥 Spiciest Users <span style="font-size:14px; opacity:0.6; margin-left:10px;">${sub}</span></h3>
                        <div style="font-size:11px; color:var(--muted); margin-top:4px;">Users with the most controversial ${isAll ? 'overall' : 'group'} takes</div>
                    </div>
                    <button onclick="fetchSpiceData(true)" style="background:transparent; border:1px solid var(--border); color:var(--muted); padding:6px 12px; border-radius:4px; cursor:pointer; font-size:12px; transition:all 0.2s;" onmouseover="this.style.color='var(--text)'; this.style.borderColor='var(--text)'" onmouseout="this.style.color='var(--muted)'; this.style.borderColor='var(--border)'">
                        ↻ Refresh
                    </button>
                </div>
            `;

            // Process results based on subgroup
            let filtered = results.map(u => ({
                username: u.username,
                score: isAll ? u.global_spice : (u.group_breakdown ? u.group_breakdown[sub] : null),
                global: u.global_spice, // Keep global for context
                raw: u // Keep raw for advanced
            })).filter(u => u.score !== null && u.score !== undefined);

            if (filtered.length === 0) {
                el.innerHTML = headerHtml + `<div style="padding:40px; color:var(--muted); text-align:center; background:var(--card-bg); border-radius:8px; border:1px solid var(--border);">No spice data found for subgroup "${sub}".</div>`;
                return;
            }

            // Sort by the absolute backend score (already normalized to 0-100)
            filtered.sort((a, b) => b.score - a.score);

            // PODIUM (Top 3)
            const top3 = filtered.slice(0, 3);
            const rest = filtered.slice(3, 23); // Top 20 after top 3

            let podiumHtml = '<div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:25px;">';
            const medals = ['🥇', '🥈', '🥉'];

            top3.forEach((u, idx) => {
                podiumHtml += `
                    <div onclick="window.showSpiceDetail('${u.username.replace(/'/g, "\\'")}')" style="background:linear-gradient(135deg, var(--card-bg) 0%, rgba(255,105,180,0.05) 100%); border:1px solid ${idx === 0 ? 'var(--gold)' : 'var(--border)'}; border-radius:12px; padding:20px; text-align:center; cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='translateY(-3px)'" onmouseout="this.style.transform='translateY(0)'">
                        <div style="font-size:24px; margin-bottom:10px;">${medals[idx]}</div>
                        <div style="font-weight:bold; font-size:16px; margin-bottom:5px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${u.username}</div>
                        <div style="font-size:24px; font-weight:900; color:var(--pink);">${u.score.toFixed(1)}</div>
                        <div style="font-size:10px; color:var(--muted); text-transform:uppercase; letter-spacing:1px; margin-bottom:4px;">Spice Score</div>
                        <div style="font-size:10px; color:var(--muted);">(out of 100)</div>
                    </div>
                `;
            });
            podiumHtml += '</div>';

            // LIST (The rest) - Use absolute scores for bars (capped at 100 for visual)
            let tableHtml = `<div style="background:var(--card-bg); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
                <table style="width:100%; border-collapse:collapse;">
                <thead style="background:rgba(255,255,255,0.02); border-bottom:1px solid var(--border);">
                    <tr>
                        <th style="padding:12px 15px; text-align:left; font-size:11px; color:var(--muted); text-transform:uppercase;">Rank</th>
                        <th style="padding:12px 15px; text-align:left; font-size:11px; color:var(--muted); text-transform:uppercase;">User</th>
                        <th style="padding:12px 15px; text-align:center; font-size:11px; color:var(--muted); text-transform:uppercase;">Spice</th>
                        ${showAdvanced && !isAll ? `<th style="padding:12px 15px; text-align:center; font-size:11px; color:var(--muted); text-transform:uppercase;">Global</th>` : ''}
                        <th style="padding:12px 15px; width:40%;"></th>
                    </tr>
                </thead><tbody>`;

            tableHtml += rest.map((u, idx) => `
                <tr onclick="window.showSpiceDetail('${u.username.replace(/'/g, "\\'")}')" style="cursor:pointer; border-bottom:1px solid rgba(255,255,255,0.03);" class="clickable-row">
                    <td style="padding:10px 15px; color:var(--muted); font-family:monospace;">#${idx + 4}</td>
                    <td style="padding:10px 15px; font-weight:600;">${u.username}</td>
                    <td style="padding:10px 15px; text-align:center; color:var(--pink); font-weight:bold;">${u.score.toFixed(1)}</td>
                    ${showAdvanced && !isAll ? `<td style="padding:10px 15px; text-align:center; color:var(--muted); font-size:12px;">${u.global.toFixed(1)}</td>` : ''}
                    <td style="padding:10px 15px;"><div class="bar-bg" style="width:100%; height:6px;"><div class="bar-fill" style="width:${Math.min(u.score, 100)}%"></div></div></td>
                </tr>
            `).join('');

            tableHtml += '</tbody></table></div>';

            // Calculate theoretical maximum spice
            // With proper normalization, max spice = 100 (perfectly inverted rankings)
            const songCount = sub === 'All Songs' ? 147 : (allSubgroups.find(s => s.name === sub)?.songs?.length || 20);

            const maxSpiceHtml = `
                <div style="margin-top:30px; padding:20px; background:linear-gradient(135deg, rgba(255,105,180,0.05) 0%, rgba(147,112,219,0.05) 100%); border:1px solid rgba(255,105,180,0.2); border-radius:12px;">
                    <h4 style="margin:0 0 15px; font-size:16px; color:var(--pink); display:flex; align-items:center; gap:10px;">
                        🧮 Theoretical Maximum Spice
                    </h4>
                    <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div style="background:rgba(0,0,0,0.2); padding:15px; border-radius:8px; text-align:center;">
                            <div style="font-size:28px; font-weight:900; color:var(--pink);">100</div>
                            <div style="font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:1px; margin-top:5px;">Max Possible Score</div>
                        </div>
                        <div style="background:rgba(0,0,0,0.2); padding:15px; border-radius:8px; text-align:center;">
                            <div style="font-size:28px; font-weight:900; color:var(--text);">${songCount}</div>
                            <div style="font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:1px; margin-top:5px;">Songs in ${sub}</div>
                        </div>
                        <div style="background:rgba(0,0,0,0.2); padding:15px; border-radius:8px; text-align:center;">
                            <div style="font-size:28px; font-weight:900; color:var(--gold);">${filtered.length > 0 ? filtered[0].score.toFixed(0) : 0}%</div>
                            <div style="font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:1px; margin-top:5px;">Top User Score</div>
                        </div>
                    </div>
                    <div style="margin-top:15px; font-size:11px; color:var(--muted); line-height:1.6;">
                        <strong>Formula:</strong> Spice = (RMS / max_RMS) × 100. Perfectly inverted rankings = 100.
                    </div>
                </div>
            `;

            el.innerHTML = headerHtml + podiumHtml + tableHtml + maxSpiceHtml;
        }

        // Explicitly attach to window to ensure global accessibility
        window.showSpiceDetail = async function (username) {
            console.log("Showing spice detail for:", username);
            const modal = document.getElementById('song-modal');
            const content = document.getElementById('song-modal-content');
            if (!modal || !content) return;

            content.innerHTML = '<div style="padding:40px; text-align:center;"><div class="spinner"></div><div style="margin-top:20px; color:var(--muted);">Analyzing spice levels...</div></div>';
            modal.classList.remove('hidden');
            modal.style.display = 'flex';

            try {
                // Fetch fresh spice data for this user
                const f = document.getElementById('view-franchise').value;
                const sub = document.getElementById('view-subgroup').value;

                // Get pre-loaded spice data from cache first to show something immediate
                const cachedUser = dataCache.spice?.results?.find(u => u.username === username);
                let scoreDisplay = 'N/A';

                if (cachedUser) {
                    if (sub === 'All Songs') {
                        scoreDisplay = cachedUser.global_spice.toFixed(2);
                    } else if (cachedUser.group_breakdown && cachedUser.group_breakdown[sub]) {
                        scoreDisplay = cachedUser.group_breakdown[sub].toFixed(2);
                    }
                }

                const res = await fetch(`${API}/analysis/spice?franchise=${f}&_t=${Date.now()}`);
                const data = await res.json();
                // Update cache with fresh data
                dataCache.spice = data;
                const userResult = data.results.find(u => u.username === username);

                if (!userResult) {
                    content.innerHTML = '<div style="padding:20px; text-align:center;">User data not found.</div>';
                    return;
                }

                // Filter extreme picks by the CURRENTLY SELECTED SUBGROUP if not "All Songs"
                let allPicks = userResult.extreme_picks || [];

                // Check if we should show global or local picks
                const showGlobal = window.spiceDetailShowGlobal || false;
                let picks = allPicks;

                console.log(`Total picks: ${allPicks.length}, Current subgroup: "${sub}", Show global: ${showGlobal}`);

                if (!showGlobal && sub !== 'All Songs') {
                    picks = allPicks.filter(p => p.group === sub);
                    console.log(`Filtered to ${picks.length} picks for "${sub}"`);
                }

                // Sort picks by deviation (descending)
                picks.sort((a, b) => b.deviation - a.deviation);

                // Limit to top 5 unless in advanced mode
                if (!window.advancedMode) {
                    picks = picks.slice(0, 5);
                }

                const showGroupColumn = showGlobal || sub === 'All Songs';

                // Calculate song count for this group
                const groupSongCount = sub === 'All Songs' ? 147 : (allSubgroups.find(s => s.name === sub)?.songs?.length || allPicks.filter(p => p.group === sub).length || 20);

                // Tab state
                const activeTab = window.spiceModalTab || 'picks';

                content.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:20px;">
                        <div>
                            <h2 style="margin:0; font-size:24px; color:var(--text);">${username}</h2>
                            <div style="color:var(--muted); font-size:14px; margin-top:5px;">Spice Analysis (${sub})</div>
                        </div>
                        <div style="text-align:right;">
                            <div style="font-size:32px; font-weight:900; color:var(--pink); line-height:1;">${scoreDisplay}</div>
                            <div style="font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:1px;">Spice Score</div>
                            ${window.advancedMode && sub !== 'All Songs' && cachedUser ?
                        `<div style="font-size:12px; color:var(--muted); margin-top:5px;">Global: <span style="color:var(--text);">${cachedUser.global_spice.toFixed(2)}</span></div>`
                        : ''}
                        </div>
                    </div>

                    <div style="margin-bottom:15px; display:flex; gap:5px; border-bottom:1px solid var(--border); padding-bottom:10px;">
                        <button onclick="window.spiceModalTab='picks'; window.showSpiceDetail('${username.replace(/'/g, "\\'")}')" 
                            style="padding:8px 16px; font-size:12px; font-weight:600; border:none; border-radius:4px 4px 0 0; cursor:pointer; background:${activeTab === 'picks' ? 'var(--pink)' : 'transparent'}; color:${activeTab === 'picks' ? '#000' : 'var(--muted)'};">
                            🔥 Extreme Picks
                        </button>
                        <button onclick="window.spiceModalTab='math'; window.showSpiceDetail('${username.replace(/'/g, "\\'")}')" 
                            style="padding:8px 16px; font-size:12px; font-weight:600; border:none; border-radius:4px 4px 0 0; cursor:pointer; background:${activeTab === 'math' ? 'var(--pink)' : 'transparent'}; color:${activeTab === 'math' ? '#000' : 'var(--muted)'};">
                            📐 How It's Calculated
                        </button>
                    </div>

                    ${activeTab === 'math' ? `
                    <div style="padding:20px; background:var(--card-bg); border:1px solid var(--border); border-radius:12px;">
                        <h3 style="margin:0 0 15px; color:var(--pink);">Spice Score Formula</h3>
                        
                        <div style="background:rgba(0,0,0,0.3); padding:20px; border-radius:8px; font-family:monospace; margin-bottom:20px;">
                            <div style="font-size:18px; color:var(--text); text-align:center;">
                                Spice = (RMS ÷ Max_RMS) × 100
                            </div>
                        </div>

                        <div style="font-size:13px; color:var(--muted); line-height:1.8;">
                            <p><strong style="color:var(--text);">Where:</strong></p>
                            <ul style="padding-left:20px; margin:10px 0;">
                                <li><strong>RMS</strong> = Root Mean Square of your deviations</li>
                                <li><strong>Max_RMS</strong> = Theoretical max RMS (${groupSongCount}/√3 ≈ ${(groupSongCount / Math.sqrt(3)).toFixed(1)})</li>
                                <li><strong>Deviation</strong> = |Your Rank − Average Rank|</li>
                            </ul>

                            <p style="margin-top:15px;"><strong style="color:var(--text);">Step by Step for ${username}:</strong></p>
                            <ol style="padding-left:20px; margin:10px 0;">
                                <li>For each song, calculate: (Your Rank − Avg Rank)²</li>
                                <li>Sum all squared deviations</li>
                                <li>Divide by number of songs (${groupSongCount}) and take square root → <strong>RMS</strong></li>
                                <li>Calculate <strong>Max_RMS</strong> = ${groupSongCount} ÷ √3 ≈ ${(groupSongCount / Math.sqrt(3)).toFixed(1)}</li>
                                <li>Normalize: (RMS ÷ Max_RMS) × 100 = <strong style="color:var(--pink);">${scoreDisplay}</strong></li>
                            </ol>

                            <div style="margin-top:20px; padding:15px; background:rgba(255,105,180,0.1); border-radius:8px;">
                                <strong style="color:var(--pink);">Maximum Possible:</strong><br>
                                If you ranked every song exactly opposite to the community average, your Spice Score would be exactly <strong>100</strong>.
                            </div>
                        </div>
                    </div>
                    ` : `

                    ${sub !== 'All Songs' && window.advancedMode ? `
                        <div style="margin-bottom:15px; display:flex; align-items:center; gap:10px;">
                            <span style="font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:1px;">Showing:</span>
                            <button 
                                onclick="window.spiceDetailShowGlobal = false; window.showSpiceDetail('${username.replace(/'/g, "\\'")}')" 
                                style="padding:6px 12px; font-size:11px; font-weight:600; border-radius:4px; cursor:pointer; transition:all 0.2s; border:1px solid var(--border); background:${!showGlobal ? 'var(--pink)' : 'transparent'}; color:${!showGlobal ? '#000' : 'var(--text)'};"
                            >
                                ${sub} Only
                            </button>
                            <button 
                                onclick="window.spiceDetailShowGlobal = true; window.showSpiceDetail('${username.replace(/'/g, "\\'")}')" 
                                style="padding:6px 12px; font-size:11px; font-weight:600; border-radius:4px; cursor:pointer; transition:all 0.2s; border:1px solid var(--border); background:${showGlobal ? 'var(--pink)' : 'transparent'}; color:${showGlobal ? '#000' : 'var(--text)'};"
                            >
                                All Groups
                            </button>
                        </div>
                    ` : (sub !== 'All Songs' ? `
                        <div style="margin-bottom:15px; font-size:12px; color:var(--muted);">
                            Showing extreme picks for <span style="color:var(--pink); font-weight:600;">${sub}</span> only
                        </div>
                    ` : '')}

                    <div style="background:var(--card-bg); border:1px solid var(--border); border-radius:12px; overflow:hidden;">
                        <table style="width:100%; border-collapse:collapse;">
                            <thead style="background:rgba(255,255,255,0.03); border-bottom:1px solid var(--border);">
                                <tr>
                                    <th style="padding:12px 15px; text-align:left; font-size:12px; color:var(--muted); text-transform:uppercase;">Song</th>
                                    ${showGroupColumn ? `<th style="padding:12px 15px; text-align:center; font-size:12px; color:var(--muted); text-transform:uppercase;">Group</th>` : ''}
                                    <th style="padding:12px 15px; text-align:center; font-size:12px; color:var(--muted); text-transform:uppercase;">Rank</th>
                                    <th style="padding:12px 15px; text-align:center; font-size:12px; color:var(--muted); text-transform:uppercase;">Avg</th>
                                    <th style="padding:12px 15px; text-align:right; font-size:12px; color:var(--muted); text-transform:uppercase;">Dev</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${picks.map(p => `
                                    <tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
                                        <td style="padding:10px 15px; font-weight:500;">${p.song}</td>
                                        ${showGroupColumn ? `<td style="padding:10px 15px; text-align:center; color:var(--muted); font-size:12px;">${p.group}</td>` : ''}
                                        <td style="padding:10px 15px; text-align:center; font-family:monospace; font-weight:bold; color:${p.user_rank < 10 ? 'var(--gold)' : 'var(--text)'}">${p.user_rank}</td>
                                        <td style="padding:10px 15px; text-align:center; font-family:monospace; color:var(--muted);">${p.avg_rank}</td>
                                        <td style="padding:10px 15px; text-align:right; font-family:monospace; font-weight:bold; color:var(--pink);">+${p.deviation}</td>
                                    </tr>
                                `).join('')}
                                ${picks.length === 0 ? `<tr><td colspan="${showGroupColumn ? 5 : 4}" style="padding:30px; text-align:center; color:var(--muted);">No extreme deviations found${!showGlobal && sub !== 'All Songs' ? ` for ${sub}` : ''}.</td></tr>` : ''}
                            </tbody>
                        </table>
                        ${!window.advancedMode && picks.length > 5 ? `<div style="padding:10px; text-align:center; font-size:12px; color:var(--muted); background:rgba(0,0,0,0.2);">Showing top 5 of ${allPicks.filter(p => showGlobal || sub === 'All Songs' || p.group === sub).length} deviations. Enable Advanced Mode for full list.</div>` : ''}
                    </div>

                    ${window.advancedMode ? `
                    <div style="margin-top:20px; padding:15px; background:rgba(255,105,180,0.05); border:1px solid rgba(255,105,180,0.2); border-radius:8px;">
                        <h4 style="margin:0 0 10px; font-size:14px; color:var(--pink);">📊 Theoretical Maximum Spice</h4>
                        <div style="font-size:12px; color:var(--muted); line-height:1.6;">
                            <p style="margin:0 0 8px;">For a group with <strong style="color:var(--text);">${sub === 'All Songs' ? allPicks.length + ' songs' : sub}</strong>:</p>
                            <ul style="margin:5px 0; padding-left:20px;">
                                <li>Max single deviation: <strong style="color:var(--pink);">~${Math.round((sub === 'All Songs' ? 147 : (allPicks.filter(p => p.group === sub).length || 20)) * 0.9)}</strong> (ranking #1 what everyone else has last)</li>
                                <li>Max Spice Score: <strong style="color:var(--pink);">~100</strong> (perfectly inverted rankings)</li>
                                <li>Your current: <strong style="color:var(--text);">${scoreDisplay}</strong> (${(parseFloat(scoreDisplay) || 0) < 30 ? 'relatively mild' : (parseFloat(scoreDisplay) || 0) < 50 ? 'moderately spicy' : 'extremely spicy'})</li>
                            </ul>
                        </div>
                    </div>
                    ` : ''}
                `}
                `;


            } catch (e) {
                console.error("Modal Render Error:", e);
                content.innerHTML = '<div style="padding:20px; color:var(--red); text-align:center;">Failed to load spice details.</div>';
            }
        }

        function renderOutliers(results) {
            const el = document.getElementById('c-outliers');
            if (!el) return;

            if (!results || !results.length) {
                el.innerHTML = '<div style="padding:10px; font-size:12px; color:var(--muted);">No spice data available.</div>';
                return;
            }

            const sub = document.getElementById('view-subgroup').value;
            const isAll = sub === 'All Songs';

            let filtered = results.map(u => ({
                username: u.username,
                score: isAll ? u.global_spice : (u.group_breakdown ? u.group_breakdown[sub] : null)
            })).filter(u => u.score !== null && u.score !== undefined);

            if (filtered.length === 0) {
                el.innerHTML = '<div style="padding:10px; font-size:12px; color:var(--muted);">No spice data for this group.</div>';
                return;
            }

            filtered.sort((a, b) => b.score - a.score);

            const limit = getLimit(10, filtered.length);
            const data = filtered.slice(0, limit);
            const scores = data.map(u => u.score), min = Math.min(...scores), max = Math.max(...scores), r = (max - min) || 1;

            el.innerHTML = `<table><colgroup><col><col class="col-metric"></colgroup><tr><th>User</th><th class="col-metric">Spice</th></tr>` +
                data.map(u => `<tr onclick="window.showSpiceDetail('${u.username.replace(/'/g, "\\'")}')" style="cursor:pointer" class="clickable-row">
                    <td style="font-weight:bold">${u.username}</td>
                    <td class="metric"><div class="bar-bg" style="width:180px"><div class="bar-fill" style="width:${((u.score - min) / r) * 100}%"></div><div style="font-size:10px; margin-top:-14px; margin-left:5px;">${u.score.toFixed(2)}</div></div></td>
                </tr>`).join('') + `</table>`;
        }


        async function renderMatrix(sub, f) {
            const wrap = document.getElementById("c-matrix"); wrap.innerHTML = "Loading...";
            try {
                const r = await fetch(`${API}/analysis/divergence?franchise=${f}&subgroup=${sub}`);
                const d = await r.json();
                const u = Object.keys(d.matrix).sort();
                const nSongs = Object.keys(d.song_names || {}).length || 1;

                // Max for coloration (cap at 40% for visual contrast, as >40% is extreme)
                const maxVal = 40;

                wrap.style.gridTemplateColumns = `150px repeat(${u.length}, 1fr)`;
                wrap.innerHTML = `<div></div>` + u.map(n => `<div class="m-label">${n}</div>`).join('');

                u.forEach(u1 => {
                    wrap.innerHTML += `<div class="m-label" style="text-align:left">${u1}</div>`;
                    u.forEach(u2 => {
                        const raw = d.matrix[u1][u2];
                        const pct = ((raw / Math.max(1, nSongs - 1)) * 100);
                        const display = pct.toFixed(0);
                        const op = Math.min(1, Math.pow(pct / maxVal, 1.5)); // Color opacity based on %

                        wrap.innerHTML += `<div class="cell" onclick="showUserComparison('${u1}', '${u2}')" style="background:rgba(219, 97, 162, ${op}); color:${op > 0.5 ? '#fff' : '#8b949e'}; border-bottom:1px solid #0d1117; cursor:pointer;" title="${u1} vs ${u2}: ${pct.toFixed(1)}%">${display}</div>`;
                    });
                });
            } catch (e) { console.error(e); wrap.innerHTML = "Error."; }
        }

        // Store tier dots globally for hover interactions
        let tierDotsData = [];
        let tierRedrawConfig = { rects: [] };
        var tierMethod = tierMethod || 'stddev'; // 'percentile', 'score', 'stddev'

        function renderTierStats(rankings, contData) {
            const total = rankings.length;

            // Get canvas and tooltip
            const canvas = document.getElementById('c-tier-dots');
            const tooltip = document.getElementById('c-tier-tooltip');

            if (total === 0) {
                document.getElementById('c-tier-bar').innerHTML = '<div style="padding:10px; color:var(--muted)">No data</div>';
                document.getElementById('c-tier-lists').innerHTML = '';
                if (canvas) { const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); }
                return;
            }

            // Build controversy map for std
            const contMap = {};
            if (contData && contData.length) {
                contData.forEach(c => contMap[c.song_name] = c.std || c.cv || 0);
            }


            const sorted = [...rankings].sort((a, b) => a.average - b.average);

            // Calculate stats for stddev method
            const avgRanks = sorted.map(s => s.average);
            const mean = avgRanks.reduce((a, b) => a + b, 0) / total;
            const stddev = Math.sqrt(avgRanks.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / total);
            tierRedrawConfig.stats = { mean, stddev };

            // Use selected method in all modes
            const method = tierMethod;

            let tiers, labels;

            switch (method) {
                case 'percentile':
                    // Equal 20% splits (quintiles)
                    const pct20 = Math.ceil(total * 0.2);
                    const pct40 = Math.ceil(total * 0.4);
                    const pct60 = Math.ceil(total * 0.6);
                    const pct80 = Math.ceil(total * 0.8);
                    tiers = {
                        S: sorted.slice(0, pct20),
                        A: sorted.slice(pct20, pct40),
                        B: sorted.slice(pct40, pct60),
                        C: sorted.slice(pct60, pct80),
                        F: sorted.slice(pct80)
                    };
                    labels = { S: 'S (Top 20%)', A: 'A (20-40%)', B: 'B (40-60%)', C: 'C (60-80%)', F: 'F (Bottom 20%)' };
                    break;

                case 'stddev':
                    // Standard Normal Distribution z-score bands
                    tiers = { S: [], A: [], B: [], C: [], F: [] };
                    sorted.forEach(r => {
                        const z = (r.average - mean) / stddev;
                        if (z <= -2) tiers.S.push(r);
                        else if (z <= -1) tiers.A.push(r);
                        else if (z <= 1) tiers.B.push(r);
                        else if (z <= 2) tiers.C.push(r);
                        else tiers.F.push(r);
                    });
                    labels = {
                        S: 'S (z < -2σ, ~2%)',
                        A: 'A (-2σ to -1σ, ~14%)',
                        B: 'B (within ±1σ, ~68%)',
                        C: 'C (+1σ to +2σ, ~14%)',
                        F: 'F (z > +2σ, ~2%)'
                    };
                    break;

                case 'score':
                default:
                    // Bell curve grading (Value-based to handle ties)
                    // We determine thresholds based on ideal counts, but assign by score
                    const s_idx = Math.min(Math.ceil(total * 0.07) - 1, total - 1);
                    const a_idx = Math.min(Math.ceil(total * 0.24) - 1, total - 1);
                    const b_idx = Math.min(Math.ceil(total * 0.74) - 1, total - 1);
                    const c_idx = Math.min(Math.ceil(total * 0.91) - 1, total - 1);

                    const score_s = sorted[s_idx].average;
                    const score_a = sorted[a_idx].average;
                    const score_b = sorted[b_idx].average;
                    const score_c = sorted[c_idx].average;

                    tiers = {
                        S: sorted.filter(r => r.average <= score_s),
                        A: sorted.filter(r => r.average > score_s && r.average <= score_a),
                        B: sorted.filter(r => r.average > score_a && r.average <= score_b),
                        C: sorted.filter(r => r.average > score_b && r.average <= score_c),
                        F: sorted.filter(r => r.average > score_c)
                    };
                    labels = {
                        S: 'S (Top 7%)',
                        A: 'A (7-24%)',
                        B: 'B (24-74%)',
                        C: 'C (74-91%)',
                        F: 'F (Bottom 9%)'
                    };
                    break;
            }

            // Assign tier metadata for dots
            sorted.forEach((r, i) => {
                r._tierRank = i + 1;
                r._std = contMap[r.song_name] || 0;
                // Find which tier this song is in
                for (const [tier, songs] of Object.entries(tiers)) {
                    if (songs.includes(r)) { r._tier = tier; break; }
                }
            });

            const colors = { S: '#e6cc00', A: '#3fb950', B: '#238636', C: '#8b949e', F: '#f85149' };

            // Render method selector (always visible)
            const methodSelectorHTML = `
                <div style="margin-bottom:15px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                    <label style="font-size:12px; color:var(--muted); text-transform:uppercase; white-space:nowrap;">Tier Method:</label>
                    <select id="tier-method-select" onchange="changeTierMethod(this.value)" style="padding:8px 12px; font-size:13px; min-width:200px;">
                        <option value="score" ${tierMethod === 'score' ? 'selected' : ''}>Bell Curve</option>
                        <option value="percentile" ${tierMethod === 'percentile' ? 'selected' : ''}>Equal Quintiles</option>
                        <option value="stddev" ${tierMethod === 'stddev' ? 'selected' : ''}>Standard Deviation</option>
                    </select>
                    <span style="font-size:11px; color:var(--muted);">μ = ${mean.toFixed(1)}, σ = ${stddev.toFixed(1)}</span>
                </div>
            `;

            // Render Bar
            const bar = document.getElementById('c-tier-bar');
            console.log('[DEBUG] renderTierStats called:', { total, tierMethod: method, tiers: Object.fromEntries(Object.entries(tiers).map(([k, v]) => [k, v.length])) });
            // Check if we need to insert the selector before the bar (if it doesn't exist yet)
            let selectorContainer = document.getElementById('tier-method-container');
            if (!selectorContainer) {
                selectorContainer = document.createElement('div');
                selectorContainer.id = 'tier-method-container';
                bar.parentNode.insertBefore(selectorContainer, bar);
            }
            selectorContainer.innerHTML = methodSelectorHTML;

            bar.innerHTML = '';
            Object.keys(tiers).forEach(k => {
                const count = tiers[k].length;
                if (count > 0) {
                    const pct = (count / total) * 100;
                    bar.innerHTML += `<div style="width:${pct}%; background:${colors[k]}; display:flex; align-items:center; justify-content:center; color:#000; font-weight:bold; font-size:11px; cursor:help;" title="${labels[k]}: ${count} songs (${pct.toFixed(1)}%)">${k}</div>`;
                }
            });

            // Render Dot Chart
            if (canvas) {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                const ctx = canvas.getContext('2d');
                const w = canvas.width, h = canvas.height;
                const paddingLeft = 30;
                const paddingRight = 50; // Extra for labels
                const usableWidth = w - paddingLeft - paddingRight;

                ctx.clearRect(0, 0, w, h);

                // Fill background to prevent black edges
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, w, h);

                const xStrategy = (method === 'stddev') ? 'z-score' : 'rank';

                // Calculate and store background rects for efficient redraw
                tierRedrawConfig.rects = [];
                let bgRects = [];

                if (xStrategy === 'z-score') {
                    const zScores = sorted.map(r => (r.average - mean) / (stddev || 1));

                    // Dynamic Range based on Occupied Tiers
                    const actualMinZ = Math.min(...zScores);
                    const actualMaxZ = Math.max(...zScores);
                    let minZ, maxZ;

                    // Left Boundary (Best/S side): S < -2, A [-2, -1], B [-1, 1]
                    if (actualMinZ < -2) minZ = Math.min(-2.25, actualMinZ - 0.1);
                    else if (actualMinZ < -1) minZ = -2;
                    else minZ = -1;

                    // Right Boundary (Worst/F side): F > 2, C [1, 2], B [-1, 1]
                    if (actualMaxZ > 2) maxZ = Math.max(2.25, actualMaxZ + 0.1);
                    else if (actualMaxZ > 1) maxZ = 2;
                    else maxZ = 1;

                    const zRange = maxZ - minZ;

                    const getX = (z) => {
                        // Clamp to min/max prevents values flying off chart
                        const val = Math.max(minZ, Math.min(maxZ, z));
                        const pct = (val - minZ) / zRange;
                        return paddingLeft + pct * usableWidth;
                    };

                    const cuts = [-2, -1, 1, 2];
                    const cutX = cuts.map(getX);
                    // No need to define x0, xF here as map covers it

                    // Use proportional widths (like top bar) to fill canvas completely
                    const tierOrder = ['S', 'A', 'B', 'C', 'F'];
                    let cumX = 0;
                    bgRects = [];
                    tierOrder.forEach(t => {
                        const count = tiers[t].length;
                        if (count > 0) {
                            const width = (count / total) * w;
                            bgRects.push({ t, x: cumX, w: width });
                            cumX += width;
                        }
                    });

                    tierRedrawConfig.getX = (r, i) => {
                        // Position by rank index (matching proportional background)
                        return ((i + 0.5) / total) * w;
                    };

                } else {
                    let xStart = 0;
                    let cumCount = 0;
                    const tierOrder = ['S', 'A', 'B', 'C', 'F'];

                    tierOrder.forEach((k, idx) => {
                        const count = tiers[k].length;
                        if (count > 0) {
                            cumCount += count;
                            let xEnd;
                            if (idx === tierOrder.length - 1 || cumCount === total) {
                                xEnd = w;
                            } else {
                                xEnd = paddingLeft + (cumCount / total) * usableWidth;
                            }
                            bgRects.push({ t: k, x: Math.max(0, xStart), w: xEnd - Math.max(0, xStart) });
                            xStart = xEnd;
                        }
                    });

                    tierRedrawConfig.getX = (r, i) => {
                        return paddingLeft + ((i + 0.5) / total) * usableWidth;
                    };
                }

                tierRedrawConfig.rects = bgRects;

                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, w, h);

                bgRects.forEach(rect => {
                    if (rect.w > 0) {
                        let fillStyle = colors[rect.t] + '25';
                        // FIX: If F tier is empty in StdDev, use C color to avoid alarming Red
                        if (tierMethod === 'stddev' && rect.t === 'F' && (!tiers.F || tiers.F.length === 0)) {
                            fillStyle = colors['C'] + '25';
                        }
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(rect.x, 0, rect.w, h);
                    }
                });

                // Draw Border Labels (Numbers)
                ctx.fillStyle = '#666';
                ctx.font = '10px Consolas, monospace';
                ctx.textAlign = 'center';

                // We draw labels at the boundaries of rects. 
                bgRects.forEach((rect, i) => {
                    if (i < bgRects.length - 1 && rect.w > 0) {
                        const boundaryX = rect.x + rect.w;

                        // Only draw if boundary is well within the canvas (avoid edge overlap)
                        if (boundaryX < 5 || boundaryX > w - 5) return;

                        // Determine label text based on method and tier
                        let label = '';
                        if (tierMethod === 'stddev') {
                            // S|A (-2), A|B (-1), B|C (+1), C|F (+2)
                            if (rect.t === 'S') label = '-2σ';
                            if (rect.t === 'A') label = '-1σ';
                            if (rect.t === 'B') label = '+1σ';
                            if (rect.t === 'C') label = '+2σ';
                        } else if (tierMethod === 'percentile') {
                            // S|A (20%), A|B (40%), etc.
                            if (rect.t === 'S') label = '20%';
                            if (rect.t === 'A') label = '40%';
                            if (rect.t === 'B') label = '60%';
                            if (rect.t === 'C') label = '80%';
                        } else if (tierMethod === 'score') {
                            if (rect.t === 'S') label = '93%'; // approx
                        }

                        if (label) {
                            // Draw vertical line? Subtle one
                            ctx.beginPath();
                            ctx.moveTo(boundaryX, 0);
                            ctx.lineTo(boundaryX, h);
                            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                            ctx.stroke();

                            // Draw Label
                            ctx.fillText(label, boundaryX, 12);
                        }
                    }
                });



                tierDotsData = [];
                const maxStd = Math.max(...sorted.map(r => r._std || 0), 1);
                const paddingY = 20;

                sorted.forEach((r, i) => {
                    const x = tierRedrawConfig.getX(r, i);
                    const std = r._std || 0;
                    const y = h - paddingY - (std / maxStd) * (h - paddingY * 2);

                    tierDotsData.push({ x, y, song: r.song_name, tier: r._tier, avg: r.average, std, rank: r._tierRank });

                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = colors[r._tier];
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                });

                // Axis labels
                ctx.fillStyle = '#8b949e';
                ctx.font = '9px Inter';
                ctx.textAlign = 'left';
                ctx.fillText('← Best', paddingLeft, h - 5);
                ctx.textAlign = 'right';
                ctx.fillText('Worst →', w - paddingRight, h - 5);
                ctx.textAlign = 'left';
                ctx.fillText('Controversial ↑', 5, 25);

                // Mouse move for tooltip
                canvas.onmousemove = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    let found = null;
                    for (const d of tierDotsData) {
                        const dist = Math.sqrt((mx - d.x) ** 2 + (my - d.y) ** 2);
                        if (dist < 8) { found = d; break; }
                    }

                    if (found) {
                        tooltip.style.display = 'block';
                        // Smart positioning - avoid right edge clipping
                        const tooltipWidth = 200; // approximate
                        let leftPos = found.x + 10;
                        if (leftPos + tooltipWidth > w) {
                            leftPos = found.x - tooltipWidth - 10;
                        }
                        tooltip.style.left = Math.max(0, leftPos) + 'px';
                        tooltip.style.top = Math.max(0, found.y - 40) + 'px';

                        // UPDATED TOOLTIP START: Show Avg or Z-Score based on method
                        let valText = `Avg: ${found.avg.toFixed(2)}`;
                        if (tierMethod === 'stddev') {
                            const z = (found.avg - mean) / stddev;
                            const sign = z > 0 ? '+' : '';
                            valText = `Z-Score: ${sign}${z.toFixed(2)}σ`;
                        }
                        tooltip.innerHTML = `<strong style="color:${colors[found.tier]}">${found.song}</strong><br>${valText} | Controversy: ${found.std.toFixed(2)}σ`;
                        // UPDATED TOOLTIP END

                        highlightSongInList(found.song, true);
                    } else {
                        tooltip.style.display = 'none';
                        highlightSongInList(null, false);
                    }
                };

                // Click to open distribution
                canvas.onclick = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    let found = null;
                    for (const d of tierDotsData) {
                        const dist = Math.sqrt((mx - d.x) ** 2 + (my - d.y) ** 2);
                        if (dist < 8) { found = d; break; }
                    }
                    if (found) {
                        showSongDistribution(found.song);
                    }
                };

                canvas.onmouseleave = () => {
                    tooltip.style.display = 'none';
                    highlightSongInList(null, false);
                };
            }

            // Render Lists
            const lists = document.getElementById('c-tier-lists');
            lists.innerHTML = '';

            Object.keys(tiers).forEach(k => {
                const tierSongs = tiers[k];
                // REVERT: Show all columns (User request: "show all columns")
                // if (!tierSongs.length) return; 

                // Add Expected count for StdDev
                let headerExtra = `(${tierSongs.length})`;
                if (tierMethod === 'stddev') {
                    const pctMap = { S: 0.022, A: 0.136, B: 0.682, C: 0.136, F: 0.022 };
                    const exp = Math.round(total * pctMap[k]);
                    headerExtra = `(Count: ${tierSongs.length} / Exp: ~${exp})`;
                }

                lists.innerHTML += `
                    <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; overflow:hidden;">
                        <div style="background:${colors[k]}; color:#000; padding:8px; font-weight:bold; text-align:center;">${labels[k]} <span style="font-size:10px; opacity:0.8;">${headerExtra}</span></div>
                        <div style="max-height:350px; overflow-y:auto;">
                            ${tierSongs.map((r, i) => {
                    const escapedName = r.song_name.replace(/'/g, "\\'");
                    let valDisplay = `#${r.average.toFixed(1)}`;
                    if (tierMethod === 'stddev') {
                        const z = (r.average - mean) / stddev;
                        const sign = z > 0 ? '+' : '';
                        valDisplay = `z ${sign}${z.toFixed(2)}σ`;
                    } else if (tierMethod === 'percentile') {
                        const pct = ((total - r._tierRank + 1) / total * 100).toFixed(0);
                        valDisplay = `${pct}%ile`;
                    }
                    return `
                                <div class="tier-song-item" data-song="${r.song_name}" style="padding:6px 10px; border-bottom:1px solid var(--border); font-size:12px; display:flex; justify-content:space-between; cursor:pointer; transition:background 0.2s;" onclick="showSongDistribution('${escapedName}')" onmouseenter="highlightDotForSong('${escapedName}')" onmouseleave="unhighlightDot()">
                                    <span>${i + 1}. ${r.song_name}</span>
                                    <span style="color:var(--muted); font-size:10px;">${valDisplay}</span>
                                </div>
                            `;
                }).join('')}
                        </div>
                    </div>
                `;
            });
        }

        // Highlight song in list when hovering dot
        function highlightSongInList(songName, highlight) {
            document.querySelectorAll('.tier-song-item').forEach(el => {
                if (highlight && el.dataset.song === songName) {
                    el.style.background = 'rgba(219, 97, 162, 0.3)';
                } else {
                    el.style.background = '';
                }
            });
        }

        // Highlight dot when hovering song in list
        let highlightedDotSong = null;
        function highlightDotForSong(songName) {
            highlightedDotSong = songName;
            redrawTierDotsWithHighlight(songName);

            // Access global tierDotsData to find position
            if (typeof tierDotsData !== 'undefined' && tierDotsData.length) {
                const found = tierDotsData.find(d => d.song === songName);
                const tooltip = document.getElementById('c-tier-tooltip');
                const canvas = document.getElementById('c-tier-dots');

                if (found && tooltip && canvas) {
                    tooltip.style.display = 'block';
                    const w = canvas.width;
                    const tooltipWidth = 200; // approximate
                    let leftPos = found.x + 10;
                    if (leftPos + tooltipWidth > w) {
                        leftPos = found.x - tooltipWidth - 10;
                    }
                    tooltip.style.left = Math.max(0, leftPos) + 'px';
                    tooltip.style.top = Math.max(0, found.y - 40) + 'px';

                    const colors = { S: '#e6cc00', A: '#3fb950', B: '#238636', C: '#8b949e', F: '#f85149' };

                    let valText = `Avg: ${found.avg.toFixed(2)}`;
                    if (tierMethod === 'stddev' && tierRedrawConfig.stats) {
                        const { mean, stddev } = tierRedrawConfig.stats;
                        const z = (found.avg - mean) / stddev;
                        const sign = z > 0 ? '+' : '';
                        valText = `Z-Score: ${sign}${z.toFixed(2)}σ`;
                    }

                    tooltip.innerHTML = `<strong style="color:${colors[found.tier]}">${found.song}</strong><br>${valText} | Controversy: ${found.std.toFixed(2)}σ`;
                }
            }
        }
        function unhighlightDot() {
            highlightedDotSong = null;
            redrawTierDotsWithHighlight(null);
            const tooltip = document.getElementById('c-tier-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }
        function redrawTierDotsWithHighlight(highlightSong) {
            const canvas = document.getElementById('c-tier-dots');
            if (!canvas || !tierDotsData.length) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const paddingLeft = 30;
            const paddingRight = 50;
            const usableWidth = w - paddingLeft - paddingRight;
            const colors = { S: '#e6cc00', A: '#3fb950', B: '#238636', C: '#8b949e', F: '#f85149' };

            ctx.clearRect(0, 0, w, h);

            // Fill background to prevent black edges
            ctx.fillStyle = '#0d1117';
            ctx.fillRect(0, 0, w, h);

            // Redraw tier backgrounds from config
            if (tierRedrawConfig && tierRedrawConfig.rects) {
                tierRedrawConfig.rects.forEach(rect => {
                    if (rect.w > 0) {
                        let fillStyle = colors[rect.t] + '25';
                        // FIX: If F tier is empty in StdDev, use C color
                        if (tierMethod === 'stddev' && rect.t === 'F' && (!tierDotsData.some(d => d.tier === 'F'))) {
                            fillStyle = colors['C'] + '25';
                        }
                        ctx.fillStyle = fillStyle;
                        ctx.fillRect(rect.x, 0, rect.w, h);
                    }
                });
            }



            // Redraw dots
            tierDotsData.forEach(d => {
                const isHighlighted = d.song === highlightSong;
                ctx.beginPath();
                ctx.arc(d.x, d.y, isHighlighted ? 8 : 4, 0, Math.PI * 2);
                ctx.fillStyle = colors[d.tier];
                ctx.fill();
                ctx.strokeStyle = isHighlighted ? '#fff' : '#000';
                ctx.lineWidth = isHighlighted ? 2 : 0.5;
                ctx.stroke();

                if (isHighlighted) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Inter';
                    // Smart text positioning - avoid clipping
                    const text = d.song.length > 20 ? d.song.substring(0, 18) + '...' : d.song;
                    ctx.textAlign = 'center';
                    let textX = d.x;
                    // Keep text within bounds
                    const textWidth = ctx.measureText(text).width;
                    if (textX - textWidth / 2 < 5) textX = textWidth / 2 + 5;
                    if (textX + textWidth / 2 > w - 5) textX = w - textWidth / 2 - 5;
                    ctx.fillText(text, textX, d.y - 12);
                }
            });

            // Axis labels
            ctx.fillStyle = '#8b949e';
            ctx.font = '9px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('← Best', paddingLeft, h - 5);
            ctx.textAlign = 'right';
            ctx.fillText('Worst →', w - paddingRight, h - 5);
            ctx.textAlign = 'left';
            ctx.fillText('Controversial ↑', 5, 15);
        }

        // Change tier method (advanced mode)
        function changeTierMethod(method) {
            tierMethod = method;
            if (dataCache.loaded && dataCache.ranks?.rankings) {
                renderTierStats(dataCache.ranks.rankings, dataCache.cont?.results || []);
            }
        }

        async function renderAffinity(subData) {
            const wrapAff = document.getElementById('c-affinity');
            const wrapUnq = document.getElementById('c-unique-favs');

            const currentSub = document.getElementById('view-subgroup').value;
            const f = document.getElementById('view-franchise').value;

            if (!currentSub || currentSub.toLowerCase().includes('all')) {
                wrapAff.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:400px; text-align:center; color:var(--muted);">
                        <div style="font-size:24px; margin-bottom:10px;">📊</div>
                        <div style="font-size:16px; font-weight:bold; color:var(--text);">Select a Subgroup</div>
                        <div style="font-size:13px; max-width:300px; margin-top:5px;">Select a specific subgroup above to reveal their unique taste profile.</div>
                    </div>
                `;
                if (wrapUnq) wrapUnq.style.display = 'none';
                return;
            }

            try {
                // Fetch Global data
                const res = await fetch(`${API}/analysis/rankings?franchise=${f}&subgroup=All%20Songs`);
                if (!res.ok) throw new Error("Global data fetch failed");
                const globalData = await res.json();

                // Fetch conformity data for Taste Makers
                const confRes = await fetch(`${API}/analysis/conformity?franchise=${f}&subgroup=${currentSub}`);
                const confData = confRes.ok ? await confRes.json() : null;

                const globalAvgs = {};
                globalData.rankings.forEach(r => globalAvgs[r.song_name] = r.average);

                const totalGlobal = globalData.rankings.length || 1;
                const totalGroup = subData.length || 1;

                // Stats Vars
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
                let n = 0;

                const points = [];
                const affinityList = [];

                subData.forEach(r => {
                    const gAvg = globalAvgs[r.song_name];
                    if (gAvg !== undefined) {
                        const gScore = 100 - ((gAvg / totalGlobal) * 100);
                        const lScore = 100 - ((r.average / totalGroup) * 100);
                        const delta = lScore - gScore;

                        points.push({
                            x: lScore,
                            y: gScore,
                            song: r.song_name,
                            delta: delta,
                            gRank: gAvg,
                            lRank: r.average
                        });

                        affinityList.push({
                            ...r,
                            global: gAvg,
                            gPct: gScore,
                            lPct: lScore,
                            delta
                        });

                        sumX += lScore;
                        sumY += gScore;
                        sumXY += lScore * gScore;
                        sumX2 += lScore * lScore;
                        sumY2 += gScore * gScore;
                        n++;
                    }
                });

                // Calculate Standard Regression and Bias
                let r2 = 0, pearson = 0, avgBias = 0;
                let slope = 1, intercept = 0;

                if (n > 1) {
                    // Pearson r & Standard R²
                    const numerator = (n * sumXY) - (sumX * sumY);
                    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
                    if (denominator !== 0) {
                        pearson = numerator / denominator;
                        r2 = pearson * pearson;
                    }

                    // Regression Line
                    slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX) || 1;
                    intercept = (sumY - slope * sumX) / n || 0;

                    // Bias (Average Deviation)
                    const sumDeltas = points.reduce((sum, p) => sum + (p.y - p.x), 0);
                    avgBias = sumDeltas / n;
                }

                // (Outlier calculation removed per user request)

                // Sort and filter lists
                const loves = [...affinityList].filter(s => s.delta > 0).sort((a, b) => b.delta - a.delta).slice(0, 10);
                const hates = [...affinityList].filter(s => s.delta < 0).sort((a, b) => a.delta - b.delta).slice(0, 10);

                // User influence analysis (Hipsters from conformity endpoint)
                let userInfluence = [];
                if (confData && confData.hipsters) {
                    userInfluence = confData.hipsters.slice(0, 5).map(h => ({
                        user: h.user_id,
                        avgDeviation: h.score // Conformity score (lower = less conforming) or deviation? Let's treat as score.
                    }));
                }

                wrapAff.innerHTML = `
                    <div style="display:grid; grid-template-columns: 1fr; gap:30px; margin-bottom:40px;">
                        
                        <!-- Chart -->
                        <div style="background:var(--card); border:1px solid var(--border); border-radius:12px; padding:20px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                                <div>
                                    <div style="font-weight:bold; font-size:16px;">Taste Matrix</div>
                                    <div style="font-size:12px; color:var(--muted);">${currentSub} (X) vs Global (Y)</div>
                                </div>
                                <div style="text-align:right;">
                                    <div style="font-size:12px; color:var(--muted); font-family:monospace;">R² = ${(r2 || 0).toFixed(3)}</div>
                                    <div style="font-size:12px; color:var(--muted); font-family:monospace;">m = ${(slope || 0).toFixed(2)} <span style="color:var(--muted); opacity:0.7;">(Slope)</span></div>
                                    <div style="font-size:12px; color:var(--muted); font-family:monospace; margin-top:2px;">
                                        ${Math.abs(avgBias) > 2 ? `<span style="color:${avgBias > 0 ? '#f87171' : '#3fb950'}">c = ${avgBias > 0 ? '+' : ''}${avgBias.toFixed(1)}</span>` : '<span style="opacity:0.5; font-size:11px;">c ≈ 0 (No Bias)</span>'}
                                    </div>
                                </div>
                            </div>
                            <div style="position:relative; height:400px; width:100%;">
                                <canvas id="aff-chart"></canvas>
                            </div>
                            <!-- Legend -->
                            ${renderColorLegend()}
                        </div>

                        <!-- Outliers Section Removed -->

                        <!-- User Influence Section -->
                        ${userInfluence.length > 0 ? `
                        <div style="background:rgba(251,146,60,0.1); border:1px solid rgba(251,146,60,0.3); border-radius:12px; padding:15px;">
                            <div style="font-weight:bold; color:#fb923c; margin-bottom:10px;">Taste Makers</div>
                            <div style="font-size:12px; color:var(--muted); margin-bottom:10px;">Users whose rankings deviate most from consensus, shaping this group's unique identity.</div>
                            <div style="display:flex; flex-wrap:wrap; gap:10px;">
                                ${userInfluence.map((u, i) => `
                                    <div style="background:rgba(251,146,60,0.15); padding:8px 14px; border-radius:8px; font-size:13px;">
                                        <span style="color:#fb923c; font-weight:bold;">#${i + 1}</span>
                                        <span style="margin-left:6px;">${u.user}</span>
                                        <span style="color:var(--muted); font-size:11px; margin-left:6px;">±${(u.avgDeviation || 0).toFixed(1)} avg</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}

                        <!-- Explanation Panel -->
                        <details style="background:rgba(255,255,255,0.03); border:1px solid var(--border); border-radius:12px; padding:15px; cursor:pointer;">
                            <summary style="font-weight:bold; color:var(--text); font-size:14px; margin-bottom:10px;">How to Read This Chart</summary>
                            <div style="font-size:13px; color:var(--muted); line-height:1.6; display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap:20px; margin-top:15px;">
                                <div>
                                    <div style="font-weight:bold; color:var(--text); margin-bottom:5px;">Axes: Percentile Ranks (0-100)</div>
                                    <div style="margin-bottom:8px;">Comparing <b>Relative Rankings</b>, not average scores. Measures "Is this in our Top X% vs Global Top X%?" to remove grading bias.</div>
                                    <div><span style="color:var(--muted);">--- Neutral Line</span>: Perfect Agreement (x=y).</div>
                                </div>
                                <div>
                                    <div style="font-weight:bold; color:var(--text); margin-bottom:5px;">Stats</div>
                                    <div><b>R² (Consistency)</b>: Scatter. 1.0 = Line-like.</div>
                                    <div><b>m (Slope)</b>: Intensity. &lt;1.0 = You are more extreme/passionate than Global.</div>
                                    <div><b>c (Bias)</b>: Calibration. Positive = You rate higher.</div>
                                </div>
                                <div>
                                    <div style="font-weight:bold; color:var(--text); margin-bottom:5px;">Colors & Meaning</div>
                                    <div><span style="color:#db61a2;">● Pink</span>: Unique Favs (Group Rank > Global).</div>
                                    <div><span style="color:#3fb950;">● Green</span>: Contrarian Dislikes (Group Rank < Global).</div>
                                    <div><span style="color:#a855f7;">● Purple</span>: Anomaly (Breaks our usual taste pattern).</div>
                                </div>
                            </div>
                        </details>

                        <!-- Cards -->
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:20px;">
                            ${renderAffinityCardSection("Core Identity (Loves)", loves, "pink", totalGroup, totalGlobal)}
                            ${renderAffinityCardSection("Contrarian Takes (Hates)", hates, "blue", totalGroup, totalGlobal)}
                        </div>

                    </div>
                `;
                if (wrapUnq) wrapUnq.style.display = 'none';

                drawAffinityChart(points, []);

            } catch (e) {
                console.error(e);
                wrapAff.innerHTML = `<div style="padding:40px; text-align:center; color:var(--red);">Failed to load data: ${e.message}</div>`;
            }
        }

        function renderColorLegend() {
            return `
                <div style="display:flex; justify-content:center; gap:20px; margin-top:10px; font-size:11px; color:var(--muted);">
                    <div style="display:flex; align-items:center; gap:5px;"><span style="width:8px; height:8px; border-radius:50%; background:rgba(219, 97, 162, 0.9);"></span> Core Identity (Loves)</div>
                    <div style="display:flex; align-items:center; gap:5px;"><span style="width:8px; height:8px; border-radius:50%; background:rgba(63, 185, 80, 0.9);"></span> Contrarian (Hates)</div>
                    <div style="display:flex; align-items:center; gap:5px;"><span style="width:8px; height:8px; border-radius:50%; background:rgba(168, 85, 247, 0.9);"></span> Outlier (Unique)</div>
                    <div style="display:flex; align-items:center; gap:5px;"><span style="width:8px; height:8px; border-radius:50%; background:rgba(255, 255, 255, 0.5);"></span> Neutral</div>
                </div>
            `;
        }

        function renderAffinityCardSection(title, songs, theme, totalGroup, totalGlobal) {
            const colorRaw = theme === 'pink' ? '219, 97, 162' : '63, 185, 80';
            const colorHex = theme === 'pink' ? '#db61a2' : '#3fb950';
            const icon = theme === 'pink' ? '💖' : '❄️';

            return `
                <div style="background:linear-gradient(180deg, rgba(${colorRaw}, 0.05) 0%, rgba(0,0,0,0) 100%); border:1px solid rgba(${colorRaw}, 0.2); border-radius:12px; overflow:hidden;">
                    <div style="padding:15px; border-bottom:1px solid rgba(${colorRaw}, 0.1); display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-weight:bold; color:${colorHex};">${icon} ${title}</span>
                    </div>
                    <div style="padding:0;">
                        ${songs.map((s, i) => `
                            <div class="aff-card-item" data-song="${s.song_name}" 
                                 style="padding:10px 15px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; font-size:13px; cursor:pointer; transition:background 0.15s;"
                                 onmouseover="highlightAffinityDot('${s.song_name.replace(/'/g, "\\'")}', true)"
                                 onmouseout="highlightAffinityDot('${s.song_name.replace(/'/g, "\\'")}', false)"
                                 onclick="showSongDistribution('${s.song_name.replace(/'/g, "\\'")}')">
                                <div>
                                    <div style="font-weight:600;">${i + 1}. ${s.song_name}</div>
                                    <div style="font-size:11px; color:var(--muted); display:flex; gap:8px;">
                                        <span>Us #${Math.round(s.average)}/${totalGroup}</span>
                                        <span style="opacity:0.3;">|</span>
                                        <span>World #${Math.round(s.global)}/${totalGlobal}</span>
                                    </div>
                                </div>
                                <div style="text-align:right;">
                                    <div style="font-weight:bold; color:${colorHex};">${theme === 'pink' ? '+' : ''}${(s.delta || 0).toFixed(0)}%</div>
                                    <div style="font-size:9px; color:${colorHex}; opacity:0.8; text-transform:uppercase; font-weight:bold; letter-spacing:0.5px; margin-top:2px;">
                                        ${Math.abs(s.delta) > 20 ? (s.delta > 0 ? 'Cult Classic' : 'Contrarian') : (s.delta > 0 ? 'Local Favorite' : 'Skeptical')}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function highlightAffinityDot(songName, isHighlight) {
            if (!window.affinityChart) return;
            const chart = window.affinityChart;
            const dataset = chart.data.datasets[0];
            const pointIndex = dataset.data.findIndex(p => p.song === songName);
            if (pointIndex === -1) return;

            // Update point radius to highlight
            if (!chart._originalRadii) {
                chart._originalRadii = dataset.data.map(() => 6);
            }

            dataset.data.forEach((p, i) => {
                if (isHighlight) {
                    dataset.pointRadius = dataset.data.map((_, idx) => idx === pointIndex ? 14 : 4);
                    dataset.pointBorderWidth = dataset.data.map((_, idx) => idx === pointIndex ? 3 : 0);
                    dataset.pointBorderColor = dataset.data.map((_, idx) => idx === pointIndex ? '#fff' : 'transparent');
                } else {
                    dataset.pointRadius = 6;
                    dataset.pointBorderWidth = 0;
                    dataset.pointBorderColor = 'transparent';
                }
            });
            chart.update('none');
        }
        // ========== SUBUNIT RANKINGS TAB ==========
        async function renderSubranks() {
            const tbody = document.getElementById('tbody-subranks');
            if (!tbody) return;
            tbody.innerHTML = '<tr><td colspan="6" style="padding:20px; text-align:center;">Loading...</td></tr>';

            const f = document.getElementById('view-franchise').value;
            let fKey = f.toLowerCase().replace(/!/g, '').replace(/ /g, '');
            if (f === "Love Live! Sunshine!!") fKey = "aqours";

            const subgroups = allSubgroups.filter(sg => sg.franchise === f || sg.franchise === fKey);

            if (subgroups.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" style="color:var(--red); padding:20px;">
                    <b>Debug Error:</b> No subgroups found.<br>
                    f: "${f}"<br>
                    fKey: "${fKey}"<br>
                    allSubgroups: ${allSubgroups.length}<br>
                    Sample Fr: "${allSubgroups[0]?.franchise}"
                </td></tr>`;
                return;
            }

            // Always fetch/use Global (All Songs) rankings for this tab to ensure consistency
            let globalRanks = null;
            try {
                // Check if we have global ranks cached for this franchise
                if (window.globalDataCache && window.globalDataCache[fKey]) {
                    globalRanks = window.globalDataCache[fKey];
                } else {
                    const res = await fetch(`${API}/analysis/rankings?franchise=${fKey}&subgroup=All%20Songs`);
                    const data = await res.json();
                    globalRanks = data.rankings;
                    if (!window.globalDataCache) window.globalDataCache = {};
                    window.globalDataCache[fKey] = globalRanks;
                }
            } catch (e) {
                tbody.innerHTML = '<tr><td colspan="6" style="color:var(--red);">Failed to load rankings</td></tr>';
                return;
            }

            const songMap = {};
            globalRanks.forEach((r, i) => songMap[r.song_name] = { rank: i + 1, score: r.average });

            // Compute stats for each subgroup
            const stats = subgroups.map(sg => {
                let totalRank = 0, validCount = 0;
                let bestSong = { name: '-', rank: 999 };

                (sg.songs || []).forEach(sName => {
                    const sData = songMap[sName];
                    if (sData) {
                        totalRank += sData.rank;
                        validCount++;
                        if (sData.rank < bestSong.rank) bestSong = { name: sName, rank: sData.rank };
                    }
                });

                const avgRank = validCount > 0 ? totalRank / validCount : 999;

                // Determine Type
                let type = "Other", typeColor = "var(--muted)";
                if (sg.is_subunit) {
                    if (sg.name.includes("Solos")) { type = "Solo"; typeColor = "var(--pink)"; }
                    else { type = "Subunit"; typeColor = "var(--purple)"; }
                } else if (sg.name === "All Songs" || sg.name === "Group Songs") {
                    type = "Main"; typeColor = "var(--green)";
                }

                return { ...sg, avgRank, bestSong, type, typeColor };
            });

            stats.sort((a, b) => a.avgRank - b.avgRank);

            tbody.innerHTML = stats.map((sg, i) => `
                <tr class="clickable-row" onclick="openSubgroupDetail('${sg.name.replace(/'/g, "\\'")}')">
                    <td class="col-rank">#${i + 1}</td>
                    <td><span style="font-size:10px; font-weight:bold; padding:3px 8px; border-radius:12px; border:1px solid ${sg.typeColor}; color:${sg.typeColor};">${sg.type}</span></td>
                    <td style="font-weight:600;">${sg.name}</td>
                    <td class="col-metric">${sg.song_count}</td>
                    <td class="col-metric">#${sg.avgRank.toFixed(1)}</td>
                    <td style="text-align:right; font-size:12px; color:var(--muted);">${truncate(sg.bestSong.name, 20)} <span style="color:var(--pink);">#${sg.bestSong.rank}</span></td>
                </tr>
            `).join('');
        }

        function openSubgroupDetail(subgroupName) {
            const f = document.getElementById('view-franchise').value;
            const sg = allSubgroups.find(s => s.name === subgroupName && s.franchise === f);
            if (!sg) return;

            const modal = document.getElementById('song-modal');
            const title = document.getElementById('song-modal-title');
            const content = document.getElementById('song-modal-content');

            title.innerText = `${sg.name} (${sg.song_count} songs)`;

            // Use global rankings for consistency in the detail view
            let globalRanks = (window.globalDataCache && window.globalDataCache[f]) ? window.globalDataCache[f] : [];
            const songMap = {};
            globalRanks.forEach((r, i) => songMap[r.song_name] = { rank: i + 1, score: r.average });

            const songList = (sg.songs || []).map(sName => {
                const data = songMap[sName] || { rank: 999, score: 0 };
                return { name: sName, ...data };
            }).sort((a, b) => a.rank - b.rank);

            content.innerHTML = `
                <div style="margin-bottom:15px; font-size:13px; color:var(--muted);">Click any song to see its global ranking distribution.</div>
                <div style="display:grid; gap:8px; max-height:60vh; overflow-y:auto;">
                    ${songList.map((s, i) => `
                        <div style="background:var(--bg); padding:12px 15px; border-radius:8px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; border:1px solid var(--border); transition:border-color 0.2s;"
                             onmouseover="this.style.borderColor='var(--pink)'" onmouseout="this.style.borderColor='var(--border)'"
                             onclick="showSongDistribution('${s.name.replace(/'/g, "\\'")}')">
                            <div style="font-weight:600;">${i + 1}. ${s.name}</div>
                            <div style="display:flex; gap:15px; align-items:center;">
                                <div style="font-size:11px; color:var(--muted);">Global #${s.rank}</div>
                                <div style="font-family:monospace; color:${s.rank <= 10 ? 'var(--pink)' : 'var(--text)'}; font-weight:bold;">${s.score.toFixed(1)}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            modal.classList.remove('hidden');
            modal.style.display = 'flex';
        }

        function drawAffinityChart(points, outliers = []) {
            const ctx = document.getElementById('aff-chart').getContext('2d');
            if (window.affinityChart) window.affinityChart.destroy();

            const outlierSongs = new Set(outliers.map(o => o.song));

            window.affinityChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Songs',
                        data: points,
                        backgroundColor: (ctx) => {
                            const p = ctx.raw;
                            if (!p) return 'rgba(255,255,255,0.3)';
                            if (outlierSongs.has(p.song)) return 'rgba(168, 85, 247, 0.9)'; // Purple for outliers
                            if (p.delta > 15) return 'rgba(219, 97, 162, 0.9)';
                            if (p.delta < -15) return 'rgba(63, 185, 80, 0.9)';
                            return 'rgba(255, 255, 255, 0.5)';
                        },
                        pointRadius: (ctx) => {
                            const p = ctx.raw;
                            return (p && outlierSongs.has(p.song)) ? 8 : 6;
                        },
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Group Score (Local Taste)' },
                            min: 0, max: 100,
                            grid: { color: '#333' }
                        },
                        y: {
                            title: { display: true, text: 'Global Score (Mainstream)' },
                            min: 0, max: 100,
                            grid: { color: '#333' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const p = context.raw;
                                    return `${p.song}: L=${p.x.toFixed(0)} / G=${p.y.toFixed(0)} (Bias: ${p.delta > 0 ? '+' : ''}${p.delta.toFixed(0)})`;
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                neutral: {
                                    type: 'line',
                                    xMin: 0, xMax: 100, yMin: 0, yMax: 100,
                                    borderColor: 'rgba(255,255,255,0.2)', borderWidth: 1, borderDash: [4, 4],
                                    label: { content: 'Neutral (x=y)', enabled: true, position: 'end', color: 'rgba(255,255,255,0.4)', font: { size: 10 } }
                                },
                                q1: { type: 'box', xMin: 50, xMax: 100, yMin: 50, yMax: 100, backgroundColor: 'rgba(255,255,255,0.02)', label: { content: 'Universal Hit', enabled: true, color: 'rgba(255,255,255,0.3)' } },
                                q2: { type: 'box', xMin: 0, xMax: 50, yMin: 50, yMax: 100, backgroundColor: 'rgba(63, 185, 80, 0.1)', label: { content: 'Overrated?', enabled: true, color: 'rgba(63, 185, 80, 0.8)' } },
                                q4: { type: 'box', xMin: 50, xMax: 100, yMin: 0, yMax: 50, backgroundColor: 'rgba(219, 97, 162, 0.1)', label: { content: 'Cult Classic', enabled: true, color: 'rgba(219, 97, 162, 0.8)' } },
                                q3: { type: 'box', xMin: 0, xMax: 50, yMin: 0, yMax: 50, backgroundColor: 'rgba(0,0,0,0.1)', label: { content: 'Miss', enabled: true, color: 'rgba(255,255,255,0.1)' } }
                            }
                        }
                    }
                }
            });
        }

        /* --- RIVALS LOGIC --- */
        var allUsers = [];

        async function fetchUserList() {
            const f = document.getElementById('view-franchise').value, sub = document.getElementById('view-subgroup').value;
            try {
                // Use divergence endpoint to get reliable user list
                const r = await fetch(`${API}/analysis/divergence?franchise=${f}&subgroup=${sub}`);
                const d = await r.json();
                allUsers = Object.keys(d.matrix).sort();

                // Update dynamic dimensionality text
                const dimCount = Object.keys(d.song_names || {}).length || "?";
                const descEl = document.getElementById('constellation-desc');
                if (descEl) {
                    descEl.childNodes[0].nodeValue = `Visualizing ${dimCount}-dimensional taste differences in 2D space. `;
                }

                // Init Graph with full data (for loading calculations)
                // Init Graph with full data (for loading calculations)
                setTimeout(() => typeof initConstellation === 'function' && initConstellation(d), 500);

                const opts = allUsers.map(u => `<option value="${u}">${u}</option>`).join('');
                ['duel-user-a', 'duel-user-b', 'match-finder-user', 'bias-user'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el && !el.innerHTML) {  // Only populate if empty to preserve selection
                        const old = el.value;
                        el.innerHTML = '<option value="">Select User</option>' + opts;
                        if (old && allUsers.includes(old)) el.value = old;
                    } else if (el && el.innerHTML === "") {
                        el.innerHTML = '<option value="">Select User</option>' + opts;
                    }
                });
            } catch (e) { }
        }

        function switchRivalTab(tab) {
            // Update button styles
            const buttons = {
                constellation: document.getElementById('rtab-constellation'),
                duel: document.getElementById('rtab-duel'),
                oshi: document.getElementById('rtab-oshi')
            };
            Object.keys(buttons).forEach(key => {
                const btn = buttons[key];
                if (key === tab) {
                    btn.style.background = 'var(--pink)';
                    btn.style.color = '#000';
                    btn.style.borderColor = 'transparent';
                } else {
                    btn.style.background = 'var(--card)';
                    btn.style.color = 'var(--text)';
                    btn.style.borderColor = 'var(--border)';
                }
            });
            // Update views
            document.getElementById('rview-constellation').classList.toggle('hidden', tab !== 'constellation');
            document.getElementById('rview-duel').classList.toggle('hidden', tab !== 'duel');
            document.getElementById('rview-oshi').classList.toggle('hidden', tab !== 'oshi');
        }

        function switchMatchTab(tab) {
            // Update button styles
            if (tab === 'oshi') fetchBiasUserList(true);
            const buttons = { duel: document.getElementById('mtab-duel'), match: document.getElementById('mtab-match'), oshi: document.getElementById('mtab-oshi') };
            Object.keys(buttons).forEach(key => {
                const btn = buttons[key];
                if (key === tab) {
                    btn.style.background = 'var(--pink)';
                    btn.style.color = '#000';
                    btn.style.borderColor = 'transparent';
                } else {
                    btn.style.background = 'var(--card)';
                    btn.style.color = 'var(--text)';
                    btn.style.borderColor = 'var(--border)';
                }
            });
            // Update views
            document.getElementById('mview-duel').classList.toggle('hidden', tab !== 'duel');
            document.getElementById('mview-match').classList.toggle('hidden', tab !== 'match');
            document.getElementById('mview-oshi').classList.toggle('hidden', tab !== 'oshi');
        }

        // Oshi Detector Functions


        async function analyzeBias() {
            const user = document.getElementById('bias-user').value;
            const resultsDiv = document.getElementById('bias-results');
            if (!user) {
                resultsDiv.innerHTML = '<div style="text-align:center; color:var(--muted);">Select a user first</div>';
                return;
            }
            resultsDiv.innerHTML = '<div style="text-align:center; color:var(--muted);">Analyzing...</div>';

            const f = document.getElementById('view-franchise').value;
            const sub = 'All Songs'; // Always use All Songs for Oshi Detector context

            try {
                // Fetch user-specific rankings from divergence endpoint
                const res = await fetch(`${API}/analysis/divergence?franchise=${f}&subgroup=${encodeURIComponent(sub)}`);
                const data = await res.json();

                if (!data.rankings || !data.song_names) {
                    resultsDiv.innerHTML = '<div style="color:var(--red);">No ranking data available</div>';
                    return;
                }

                // Build song name -> user rank map and global weighted average
                const userRanks = {};
                const allRanksValues = [];
                for (const [songId, rankings] of Object.entries(data.rankings)) {
                    const songName = data.song_names[songId];
                    if (rankings[user] !== undefined) {
                        userRanks[songName] = rankings[user];
                        allRanksValues.push(rankings[user]);
                    }
                }

                const globalAvg = allRanksValues.reduce((a, b) => a + b, 0) / (allRanksValues.length || 1);
                window.lastBiasGlobalAvg = Math.round(globalAvg);

                // Find all solo subgroups for this franchise
                const soloSubgroups = allSubgroups.filter(sg =>
                    sg.franchise === f &&
                    sg.is_subunit &&
                    sg.name.includes('Solos')
                );

                if (soloSubgroups.length === 0) {
                    resultsDiv.innerHTML = '<div style="color:var(--muted);">No solo subgroups defined for this franchise</div>';
                    return;
                }

                // Identify "true" subunit songs to exclude from solo counts
                const trueSubunits = allSubgroups.filter(sg => sg.franchise === f && sg.is_subunit && !sg.name.includes('Solos'));
                const subunitSongs = new Set();
                trueSubunits.forEach(sg => (sg.songs || []).forEach(s => subunitSongs.add(s)));

                // Calculate average rank and bias for each character's solo songs
                const characterScores = soloSubgroups.map(sg => {
                    const charName = sg.name.replace(' Solos', '');
                    let totalRank = 0;
                    let count = 0;
                    const rankedSongs = [];

                    (sg.songs || []).forEach(songName => {
                        // EXCLUDE songs that belong to named subunits (CatChu!, etc.)
                        if (subunitSongs.has(songName)) return;

                        if (userRanks[songName] !== undefined) {
                            totalRank += userRanks[songName];
                            count++;
                            rankedSongs.push({ name: songName, rank: userRanks[songName] });
                        }
                    });

                    const avg_rank = count > 0 ? parseFloat((totalRank / count).toFixed(1)) : 999;
                    const bias = count > 0 ? parseFloat((globalAvg - avg_rank).toFixed(1)) : 0;
                    const pureCount = (sg.songs || []).filter(s => !subunitSongs.has(s)).length;

                    return {
                        name: charName,
                        avg_rank,
                        bias,
                        count,
                        totalSongs: pureCount,
                        songs: rankedSongs.sort((a, b) => a.rank - b.rank)
                    };
                }).filter(c => c.count > 0).sort((a, b) => b.bias - a.bias);

                // Render results
                if (characterScores.length === 0) {
                    resultsDiv.innerHTML = '<div style="color:var(--muted);">No solo songs ranked by this user</div>';
                    return;
                }

                window.lastBiasData = characterScores;

                let html = '';
                characterScores.forEach((b, i) => {
                    const isTop = i === 0;
                    const biasColor = b.bias > 0 ? (isTop ? 'var(--pink)' : 'var(--green)') : 'var(--red)';
                    html += `
                     <div class="stat-card" 
                          onclick="this.nextElementSibling.classList.toggle('hidden')"
                          style="padding:15px; border-color:${isTop ? 'var(--pink)' : 'var(--border)'}; cursor:pointer; transition:all 0.2s; position:relative;">
                        <div style="font-size:10px; opacity:0.7; text-transform:uppercase; letter-spacing:1px;">${isTop ? '🏆 OSHI' : 'Favored Member'}</div>
                        <div style="font-size:16px; font-weight:bold; color:#fff; margin:5px 0;">${b.name}</div>
                        <div style="font-size:24px; font-weight:900; color:${biasColor}">
                            ${b.bias > 0 ? '+' : ''}${b.bias}
                        </div>
                        <div style="font-size:11px; opacity:0.5; margin-top:5px;">Avg Rank #${b.avg_rank} (${b.count}/${b.totalSongs})</div>
                        <div style="font-size:9px; color:var(--pink); margin-top:8px; opacity:0.6;">Click to view songs ↓</div>
                     </div>
                     <div class="hidden card" style="grid-column: 1 / -1; margin: -10px 0 20px 0; padding:15px; border-top:none; border-top-left-radius:0; border-top-right-radius:0; background:rgba(0,0,0,0.3);">
                        <div style="display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:10px;">
                            ${b.songs.map(s => `
                                <div style="display:flex; justify-content:space-between; font-size:11px; padding:5px; background:rgba(255,255,255,0.05); border-radius:4px;">
                                    <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-right:10px;">${s.name}</span>
                                    <span style="font-family:monospace; font-weight:bold; color:${s.rank <= 10 ? 'var(--pink)' : s.rank <= 30 ? 'var(--green)' : 'inherit'};">#${s.rank}</span>
                                </div>
                            `).join('')}
                        </div>
                     </div>`;
                });
                resultsDiv.innerHTML = html;
            } catch (e) {
                resultsDiv.innerHTML = `<div style="color:var(--red);">Error: ${e.message}</div>`;
            }
        }


        async function runDuel() {
            const u1 = document.getElementById('duel-user-a').value;
            const u2 = document.getElementById('duel-user-b').value;
            if (!u1 || !u2 || u1 === u2) {
                document.getElementById('duel-results').classList.add('hidden');
                return;
            }

            const f = document.getElementById('view-franchise').value, sub = document.getElementById('view-subgroup').value;
            document.getElementById('duel-score').innerHTML = "...";
            document.getElementById('duel-results').classList.remove('hidden');

            try {
                // Fetch Global data for context if not present
                let globalAvgs = {};
                if (!window.globalDataCache) {
                    const gRes = await fetch(`${API}/analysis/rankings?franchise=${f}&subgroup=All%20Songs`);
                    if (gRes.ok) {
                        const gData = await gRes.json();
                        window.globalDataCache = {};
                        gData.rankings.forEach(r => window.globalDataCache[r.song_name] = r.average);
                    }
                }
                globalAvgs = window.globalDataCache || {};

                const res = await fetch(`${API}/analysis/head-to-head?franchise=${f}&subgroup=${sub}&user_a=${u1}&user_b=${u2}`);
                const data = await res.json();

                // Render Score
                const sc = data.score;
                document.getElementById('duel-score').innerHTML = `${sc}%`;
                document.getElementById('duel-score').style.color = sc > 75 ? 'var(--green)' : sc < 40 ? 'var(--red)' : '#fff';
                document.getElementById('duel-msg').innerHTML = sc > 85 ? "BEST FRIENDS FOREVER 💖" : sc > 60 ? "Solid Compatibility 👍" : sc < 30 ? "MORTAL ENEMIES 💀" : "It's Complicated 🤷";

                // Render Disputes
                const limit = getLimit(10, data.diffs.length);
                const disputes = data.diffs.slice(0, limit);
                document.getElementById('duel-disputes').innerHTML = `<table>
                    <colgroup><col><col style="width:60px"><col style="width:60px"><col style="width:60px"><col style="width:50px"></colgroup>
                    <tr><th>Song</th><th>${u1}</th><th>${u2}</th><th>Global</th><th>Diff</th></tr>` +
                    disputes.map(d => `
                        <tr onclick="showSongDistribution('${d.name.replace(/'/g, "\\'")}')" style="cursor:pointer;" class="clickable-row">
                            <td>${d.name}</td>
                            <td style="color:${d.r1 < d.r2 ? 'var(--green)' : 'var(--muted)'}">#${d.r1}</td>
                            <td style="color:${d.r2 < d.r1 ? 'var(--green)' : 'var(--muted)'}">#${d.r2}</td>
                            <td style="color:var(--muted); opacity:0.6;">#${(globalAvgs[d.name] || 0).toFixed(0)}</td>
                            <td style="font-weight:bold; color:var(--red)">${Math.round(d.diff)}</td>
                        </tr>`).join('') + `</table>`;

            } catch (e) {
                console.error(e);
                document.getElementById('duel-score').innerHTML = "Err";
            }
        }

        async function findMatches() {
            const u = document.getElementById('match-finder-user').value;
            if (!u) return;
            const f = document.getElementById('view-franchise').value, sub = document.getElementById('view-subgroup').value;
            const res = document.getElementById('match-results');
            res.innerHTML = "Scanning database...";

            try {
                const r = await fetch(`${API}/analysis/user-match?franchise=${f}&subgroup=${sub}&user=${u}`);
                const data = await r.json();

                const renderCard = (title, list, color) => `
                    <div class="card" style="border-color:${color}">
                        <h3 style="color:${color}; border-color:${color}; margin-bottom:10px;">${title}</h3>
                        ${list.map(x => `<div style="display:flex; justify-content:space-between; padding:10px 0; border-bottom:1px solid rgba(255,255,255,0.05)">
                            <span style="font-weight:600">${x.user}</span>
                            <span style="font-family:Consolas; opacity:0.7">Div: ${x.div.toFixed(2)}</span>
                        </div>`).join('')}
                    </div>
                `;

                res.innerHTML = renderCard("❤️ Soulmates", data.soulmates, "var(--green)") +
                    renderCard("💀 Nemeses", data.nemeses, "var(--red)");
            } catch (e) {
                console.error('Match finding error:', e);
                res.innerHTML = `<div class="card" style="border-color:var(--red); text-align:center; padding:30px;">
                    <div style="font-size:48px; margin-bottom:10px;">⚠️</div>
                    <div style="color:var(--red); font-weight:600; margin-bottom:10px;">Error Finding Matches</div>
                    <div style="font-size:12px; color:var(--muted);">The API endpoint may not be available. Please check the backend service.</div>
                </div>`;
            }
        }

        async function fetchBiasUserList(autoAnalyze = false) {
            const f = document.getElementById('view-franchise').value;
            const sub = document.getElementById('view-subgroup').value;
            const sel = document.getElementById('bias-user');
            if (!sel) return;

            try {
                const res = await fetch(`${API}/users/rankings?franchise=${f}&subgroup=${encodeURIComponent(sub)}`);
                if (!res.ok) return;
                const data = await res.json();
                if (data.users && data.users.length > 0) {
                    const current = sel.value;
                    sel.innerHTML = data.users.map(u => `<option value="${u.username}">${u.username}</option>`).join('');

                    if (current && data.users.some(u => u.username === current)) {
                        sel.value = current;
                    } else if (autoAnalyze) {
                        // Auto-select first user and analyze
                        sel.value = data.users[0].username;
                        analyzeBias();
                    }
                }
            } catch (e) { console.error("Error fetching users:", e); }
        }


        /* --- CONSTELLATION GRAPH --- */
        var graphCtx = null, graphNodes = [], graphEdges = [], graphAnimParams = { w: 0, h: 0 };
        var graphHover = null, graphDrag = null, graphMouse = { x: 0, y: 0 };

        // --- Math Helpers for MDS ---
        var MathLib = {
            mean: (arr) => arr.reduce((a, b) => a + b, 0) / arr.length,
            pearson: (x, y) => {
                const n = x.length;
                if (n !== y.length || n === 0) return 0;
                const mx = MathLib.mean(x), my = MathLib.mean(y);
                let num = 0, dx2 = 0, dy2 = 0;
                for (let i = 0; i < n; i++) {
                    const dx = x[i] - mx, dy = y[i] - my;
                    num += dx * dy;
                    dx2 += dx * dx;
                    dy2 += dy * dy;
                }
                return (dx2 === 0 || dy2 === 0) ? 0 : num / Math.sqrt(dx2 * dy2);
            },
            jacobi: (A, tol = 1e-8, maxIter = 100) => {
                const n = A.length;
                let V = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0));
                let D = A.map(row => [...row]);
                for (let iter = 0; iter < maxIter; iter++) {
                    let maxVal = 0, p = 0, q = 0;
                    for (let i = 0; i < n - 1; i++) for (let j = i + 1; j < n; j++) if (Math.abs(D[i][j]) > maxVal) { maxVal = Math.abs(D[i][j]); p = i; q = j; }
                    if (maxVal < tol) break;
                    const phi = 0.5 * Math.atan2(2 * D[p][q], D[q][q] - D[p][p]);
                    const c = Math.cos(phi), s = Math.sin(phi);
                    for (let i = 0; i < n; i++) {
                        let t = D[i][p]; D[i][p] = c * t - s * D[i][q]; D[i][q] = s * t + c * D[i][q];
                        t = V[i][p]; V[i][p] = c * t - s * V[i][q]; V[i][q] = s * t + c * V[i][q];
                    }
                    for (let i = 0; i < n; i++) {
                        D[p][i] = D[i][p]; D[q][i] = D[i][q];
                    }
                    D[p][p] = c * D[p][p] * c - 2 * s * D[p][q] * c + s * D[q][q] * s;
                    D[q][q] = s * D[p][p] * s + 2 * s * D[p][q] * c + c * D[q][q] * c;
                    D[p][q] = D[q][p] = 0;
                }
                const eig = D.map((r, i) => ({ val: r[i], vec: V.map(row => row[i]) }));
                return eig.sort((a, b) => b.val - a.val);
            },
            mds: (distMatrix) => {
                const n = distMatrix.length;
                const D2 = distMatrix.map(row => row.map(v => v * v));
                const rowMeans = D2.map(r => MathLib.mean(r));
                const colMeans = Array(n).fill(0).map((_, i) => MathLib.mean(D2.map(r => r[i])));
                const matrixMean = MathLib.mean(rowMeans);
                const B = Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) =>
                    -0.5 * (D2[i][j] - rowMeans[i] - colMeans[j] + matrixMean)
                ));
                const eig = MathLib.jacobi(B);

                // Calculate variance explained by top 2 dimensions
                const positiveEigs = eig.filter(e => e.val > 0).map(e => e.val);
                const totalVar = positiveEigs.reduce((a, b) => a + b, 0);
                const explainedVar = (positiveEigs.length >= 2 && totalVar > 0)
                    ? ((positiveEigs[0] + positiveEigs[1]) / totalVar) * 100
                    : 100;

                const X = eig[0].val > 0 ? eig[0].vec.map(v => v * Math.sqrt(eig[0].val)) : Array(n).fill(0);
                const Y = eig[1].val > 0 ? eig[1].vec.map(v => v * Math.sqrt(eig[1].val)) : Array(n).fill(0);
                const Z = (eig[2] && eig[2].val > 0) ? eig[2].vec.map(v => v * Math.sqrt(eig[2].val)) : Array(n).fill(0);

                return {
                    coords: X.map((x, i) => ({ x, y: Y[i], z: Z[i] })),
                    varianceExplained: Math.round(explainedVar)
                };
            }
        };

        var graphVarianceExplained = 0; // Store for legend
        var graphPC1Songs = []; // Top 3 songs defining X-axis
        var graphPC2Songs = []; // Top 3 songs defining Y-axis

        function initConstellation(data) {
            // data = { matrix: {...}, rankings: {...}, song_names: {...} }
            console.log("DEBUG: initConstellation ENTRY. Data keys:", Object.keys(data));

            // Cache for re-render on zoom toggle
            lastConstellationData = data;

            const matrixData = data.matrix;
            const songRankings = data.rankings || {};
            const songNames = data.song_names || {};
            const cvs = document.getElementById('taste-canvas');
            if (!cvs) { console.error("DEBUG: taste-canvas NOT FOUND"); return; }
            if (!matrixData) { console.error("DEBUG: matrixData missing"); return; }
            const rect = cvs.getBoundingClientRect();
            cvs.width = rect.width; cvs.height = rect.height;
            graphCtx = cvs.getContext('2d');
            console.log("DEBUG: initConstellation started. Users:", Object.keys(matrixData).length);

            const users = Object.keys(matrixData);
            const distMatrix = users.map(u1 => users.map(u2 => matrixData[u1][u2]));

            let mdsResult;
            try { mdsResult = MathLib.mds(distMatrix); } catch (e) { console.error("MDS Failed", e); return; }

            const coords = mdsResult.coords;
            graphVarianceExplained = mdsResult.varianceExplained;

            // Calculate data bounds (max distance from center to any dot)
            let maxDist = 0;
            coords.forEach(p => {
                const d = Math.sqrt(p.x * p.x + p.y * p.y);
                if (d > maxDist) maxDist = d;
            });

            // Calculate Theoretical Max Radius
            const N = Object.keys(songNames).length;
            const theoMax = N > 1 ? Math.sqrt((Math.pow(N, 2) - 1) / 3) : 0;

            const padding = 40;
            const w = cvs.width, h = cvs.height;
            const safeRadius = Math.min(w, h) / 2 - padding;

            // Determine outer bound based on zoom mode
            let outerBound;
            if (window.constellationZoom === 'limit' && theoMax > 0) {
                outerBound = theoMax;
            } else {
                outerBound = maxDist || 1;
            }

            const scale = safeRadius / outerBound;
            window.graphScale = scale;
            window.theoMax = theoMax; // Store for drawing limit ring

            // Update dimension text (Song Count = Dimensions of Taste Space)
            const dimCount = N;
            const dimEl = document.getElementById('constellation-dims');
            if (dimEl) dimEl.textContent = `${dimCount}-dimensional`;

            graphNodes = users.map((u, i) => ({
                id: u,
                x: coords[i].x * scale + w / 2,
                y: coords[i].y * scale + h / 2,

                // 3D Real World Coords (Centered)
                realX: coords[i].x * scale,
                realY: coords[i].y * scale,
                realZ: coords[i].z * scale,

                color: `hsl(${280 + ((i * 40) % 80)}, 70%, 60%)`,
                initials: u.substring(0, 2).toUpperCase(),
                pc1: coords[i].x, // Store raw PC coords for loading calc
                pc2: coords[i].y,
                pc3: coords[i].z
            }));

            // Compute Song Loadings (Pearson correlation of song ranks with PC scores)
            const pc1Coords = graphNodes.map(n => n.pc1);
            const pc2Coords = graphNodes.map(n => n.pc2);
            const pc3Coords = graphNodes.map(n => n.pc3);

            const songLoadings = [];
            for (const [songId, userRanks] of Object.entries(songRankings)) {
                // Build rank vector aligned with users array
                const rankVec = users.map(u => userRanks[u] ?? 0);

                // Pearson correlation with PC scores
                const r1 = MathLib.pearson(rankVec, pc1Coords);
                const r2 = MathLib.pearson(rankVec, pc2Coords);
                const r3 = MathLib.pearson(rankVec, pc3Coords);

                songLoadings.push({
                    id: songId,
                    name: songNames[songId] || songId.substring(0, 8),
                    pc1: r1,
                    pc2: r2,
                    pc3: r3
                });
            }

            // Helper to generate "Vs" labels
            const getAxisLabel = (loadings, axisName) => {
                const sorted = [...loadings].sort((a, b) => Math.abs(b[axisName]) - Math.abs(a[axisName]));
                if (sorted.length < 1) return `${axisName.toUpperCase()}: Variance`;
                const s1 = sorted[0];
                const s2 = sorted[1];

                // If only 1 song or 2nd is weak, just show top
                if (!s2 || Math.abs(s2[axisName]) < 0.3) {
                    return `${axisName.toUpperCase()}: Polarized by "${s1.name}"`;
                }
                // If signs oppose, it's a VS
                if (Math.sign(s1[axisName]) !== Math.sign(s2[axisName])) {
                    return `${axisName.toUpperCase()}: "${s1.name}" vs "${s2.name}"`;
                } else {
                    return `${axisName.toUpperCase()}: Driven by "${s1.name}" & "${s2.name}"`;
                }
            };

            window.graphAxisLabels = {
                x: getAxisLabel(songLoadings, 'pc1'),
                y: getAxisLabel(songLoadings, 'pc2'),
                z: getAxisLabel(songLoadings, 'pc3')
            };

            // Store full data for drill-down
            window.graphAxisData = {
                pc1: [...songLoadings].sort((a, b) => Math.abs(b.pc1) - Math.abs(a.pc1)),
                pc2: [...songLoadings].sort((a, b) => Math.abs(b.pc2) - Math.abs(a.pc2)),
                pc3: [...songLoadings].sort((a, b) => Math.abs(b.pc3) - Math.abs(a.pc3))
            };

            // Store rankings and song names for position analysis
            window.graphRankingsData = songRankings;
            window.graphSongNames = songNames;
            window.graphUsers = users;

            // Populate divergence rankings panel
            console.log("DEBUG: Updating Stats Panel. graphNodes:", graphNodes.length);
            const maxPC1 = Math.max(...graphNodes.map(n => Math.abs(n.pc1)));
            const maxPC2 = Math.max(...graphNodes.map(n => Math.abs(n.pc2)));
            const usersByMag = graphNodes.map(n => ({
                ...n,
                magnitude: Math.sqrt(n.pc1 * n.pc1 + n.pc2 * n.pc2)
            })).sort((a, b) => b.magnitude - a.magnitude);
            const maxMag = usersByMag[0]?.magnitude || 0;

            // Update stats display
            const statPC1El = document.getElementById('stat-max-pc1');
            const statPC2El = document.getElementById('stat-max-pc2');
            const statMagEl = document.getElementById('stat-max-mag');

            // Use theoMax from scope (already calculated and stored in window.theoMax)

            if (statPC1El) statPC1El.textContent = maxPC1.toFixed(3);
            if (statPC2El) statPC2El.textContent = maxPC2.toFixed(3);
            if (statMagEl) {
                statMagEl.innerHTML = `<span style="color:#fff">${maxMag.toFixed(3)}</span> / <span style="color:var(--muted)">${(window.theoMax || 0).toFixed(3)}</span>`;
            }

            // Populate user rankings
            const rankingsEl = document.getElementById('constellation-user-rankings');
            if (rankingsEl) {
                console.log("DEBUG: Found rankingsEl, updating HTML...");
                rankingsEl.innerHTML = `
                    <table style="width:100%; border-collapse:collapse;">
                        <thead>
                            <tr style="border-bottom:1px solid var(--border); font-size:10px; color:var(--muted); text-transform:uppercase;">
                                <th style="text-align:left; padding:6px 4px;">User</th>
                                <th style="text-align:center; padding:6px 4px;">Mag</th>
                                <th style="text-align:center; padding:6px 4px;">PC1</th>
                                <th style="text-align:center; padding:6px 4px;">PC2</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${usersByMag.map((u, i) => `
                                <tr onclick="showUserPositionMath(graphNodes.find(n => n.id === '${u.id}'))" 
                                    style="cursor:pointer; border-bottom:1px solid rgba(255,255,255,0.03);"
                                    onmouseover="this.style.background='rgba(219,97,162,0.1)'"
                                    onmouseout="this.style.background='transparent'">
                                    <td style="padding:8px 4px;">
                                        <span style="color:var(--muted); font-size:10px; margin-right:6px;">#${i + 1}</span>
                                        <span style="font-weight:600; color:#fff;">${u.id}</span>
                                    </td>
                                    <td style="text-align:center; padding:8px 4px; font-family:monospace; font-weight:bold; color:${i === 0 ? 'var(--pink)' : '#fff'};">
                                        ${u.magnitude.toFixed(2)}
                                    </td>
                                    <td style="text-align:center; padding:8px 4px; font-family:monospace; font-size:11px; color:${u.pc1 > 0 ? 'var(--green)' : 'var(--red)'};">
                                        ${u.pc1 > 0 ? '+' : ''}${u.pc1.toFixed(2)}
                                    </td>
                                    <td style="text-align:center; padding:8px 4px; font-family:monospace; font-size:11px; color:${u.pc2 > 0 ? 'var(--green)' : 'var(--red)'};">
                                        ${u.pc2 > 0 ? '+' : ''}${u.pc2.toFixed(2)}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }

            // Global helper for showing details (now uses MODAL instead of alert)
            window.showAxisDetails = (title, data, key) => {
                const modal = document.getElementById('song-modal');
                const content = document.getElementById('song-modal-content');
                document.getElementById('song-modal-title').textContent = title + " Drivers";
                modal.classList.remove('hidden');
                modal.style.display = 'flex';

                const limit = getLimit(10, data.length);
                const topSongs = data.slice(0, limit);

                content.innerHTML = `
                    <div style="font-size:12px; color:var(--muted); margin-bottom:15px; text-align:center;">
                        High magnitude Pearson correlation indicates a strong driver of this axis. Click any song for distribution.
                    </div>
                    <div style="max-height:60vh; overflow-y:auto; padding-right:5px;">
                        ${topSongs.map((s, i) => `
                            <div class="axis-item" onclick="showSongDistribution('${s.name.replace(/'/g, "\\'")}')">
                                <div style="display:flex; align-items:center; gap:12px;">
                                    <span style="font-family:monospace; color:var(--muted); font-size:11px;">${(i + 1).toString().padStart(2, '0')}</span>
                                    <span style="font-weight:600;">${s.name}</span>
                                </div>
                                <div style="font-weight:900; color:${s[key] > 0 ? 'var(--green)' : 'var(--red)'}; font-family:monospace;">
                                    ${s[key] > 0 ? '+' : ''}${s[key].toFixed(3)}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            };

            window.showMetricsHelp = () => {
                const modal = document.getElementById('song-modal');
                const content = document.getElementById('song-modal-content');
                document.getElementById('song-modal-title').textContent = "Guide: Constellation Metrics";
                modal.classList.remove('hidden');
                modal.style.display = 'flex';

                content.innerHTML = `
                    <div style="font-size:13px; line-height:1.6; color:#ccc;">
                        <p>The <b>Taste Constellation</b> uses statistical analysis to map the social geography of the group.</p>
                        
                        <div style="margin-bottom:20px;">
                            <h4 style="color:var(--pink); margin-bottom:5px;">1. Magnitude (Distance from Center)</h4>
                            <div>The <b>Center (0,0)</b> represents the <b>Community Consensus</b>—the theoretical average taste of the group.</div>
                            <ul style="margin:5px 0 10px 20px; color:var(--muted);">
                                <li><b>Low Magnitude:</b> Your rankings are very close to the community average.</li>
                                <li><b>High Magnitude:</b> Your rankings strongly diverge from the group.</li>
                            </ul>
                            <div style="font-size:11px; font-style:italic; opacity:0.7;">Note: "High" and "Low" are relative to the specific group's diversity.</div>
                        </div>

                        <div style="margin-bottom:20px;">
                            <h4 style="color:var(--pink); margin-bottom:5px;">2. The Axes (Direction of Taste)</h4>
                            <div>
                                <b>Distance = Disagreement.</b> The further apart two people are, the more they disagree.
                                The axes represent the <i>primary trends</i> of that disagreement.
                            </div>
                            <ul style="margin:5px 0 0 20px; color:var(--muted);">
                                <li><b>X-Axis (PC1):</b> The single biggest factor dividing the group (e.g., "Old vs New").</li>
                                <li><b>Y-Axis (PC2):</b> The second biggest factor, distinguishing nuance between users.</li>
                            </ul>
                        </div>
                    </div>
                `;
            };

            // Click Handler for Drill-Down
            cvs.onclick = e => {
                const r = cvs.getBoundingClientRect();
                const x = e.clientX - r.left, y = e.clientY - r.top;
                const w = cvs.width, h = cvs.height;
                const cx = w / 2, cy = h / 2;

                // Node Click (Works for both 2D and 3D if graphHover is set)
                // In 3D mode, the hover logic sets graphHover to the Projected Node.
                // We must pass that to showUserPositionMath.

                if (graphHover) {
                    window.showUserPositionMath(graphHover);
                    return;
                }

                if (window.graphIs3D) return; // Skip axis clicks in 3D

                if (window.graphIs3D) return; // Skip axis clicks in 3D

                // Click X-Axis Label (Right area) - REDUCED hitbox
                if (x > w - 120 && Math.abs(y - cy) < 25) {
                    window.showAxisDetails('X-Axis', window.graphAxisData.pc1, 'pc1');
                    return;
                }
                // Click Y-Axis Label (Top center area) - REDUCED hitbox
                if (Math.abs(x - cx) < 100 && y < 35) {
                    window.showAxisDetails('Y-Axis', window.graphAxisData.pc2, 'pc2');
                    return; // Removed trailing brace
                }
            };

            // Show user's position math
            window.showUserPositionMath = function (node) {
                const modal = document.getElementById('song-modal');
                const content = document.getElementById('song-modal-content');
                const title = document.getElementById('song-modal-title');

                title.textContent = `${node.id}'s Position Analysis`;
                modal.classList.remove('hidden');
                modal.style.display = 'flex';

                // Calculate distance from origin (community consensus)
                const distance = Math.sqrt(node.pc1 * node.pc1 + node.pc2 * node.pc2 + node.pc3 * node.pc3).toFixed(2);
                const distance2D = Math.sqrt(node.pc1 * node.pc1 + node.pc2 * node.pc2).toFixed(2);

                // Advanced Mode: Calculate per-song contributions
                let songContributionHTML = '';

                // Debug checks
                const hasRanks = window.graphRankingsData && Object.keys(window.graphRankingsData).length > 0;
                // Song contribution analysis (always shown when data available)
                if (hasRanks && window.graphAxisData) {
                    const songContributions = [];

                    // Calculate mean ranks for normalization
                    const meanRanks = {};
                    for (const [songId, userRanks] of Object.entries(window.graphRankingsData)) {
                        const ranks = Object.values(userRanks);
                        meanRanks[songId] = ranks.reduce((a, b) => a + b, 0) / ranks.length;
                    }

                    // For each song, calculate its contribution
                    for (const songData of window.graphAxisData.pc1) {
                        const songId = songData.id;
                        const userRank = window.graphRankingsData[songId]?.[node.id];

                        if (userRank !== undefined) {
                            const deviation = userRank - meanRanks[songId];
                            const pc2Data = window.graphAxisData.pc2.find(s => s.id === songId);
                            const pc3Data = window.graphAxisData.pc3.find(s => s.id === songId);

                            songContributions.push({
                                name: songData.name,
                                rank: userRank,
                                mean: meanRanks[songId].toFixed(1),
                                deviation: deviation.toFixed(1),
                                pc1Contrib: (songData.pc1 * deviation).toFixed(3),
                                pc2Contrib: ((pc2Data?.pc2 || 0) * deviation).toFixed(3),
                                pc3Contrib: ((pc3Data?.pc3 || 0) * deviation).toFixed(3)
                            });
                        }
                    }

                    // Sort by absolute total contribution
                    songContributions.sort((a, b) => {
                        const totA = Math.abs(parseFloat(a.pc1Contrib)) + Math.abs(parseFloat(a.pc2Contrib));
                        const totB = Math.abs(parseFloat(b.pc1Contrib)) + Math.abs(parseFloat(b.pc2Contrib));
                        return totB - totA;
                    });

                    if (songContributions.length > 0) {
                        // Calculate totals for net effect
                        let totalPC1 = 0, totalPC2 = 0, totalPC3 = 0;
                        songContributions.forEach(s => {
                            totalPC1 += parseFloat(s.pc1Contrib);
                            totalPC2 += parseFloat(s.pc2Contrib);
                            totalPC3 += parseFloat(s.pc3Contrib);
                        });
                        const totalMag = Math.sqrt(totalPC1 ** 2 + totalPC2 ** 2);
                        const totalAngle = Math.atan2(totalPC2, totalPC1);

                        // Find max contribution magnitude for scaling vectors
                        let maxMag = 0;
                        songContributions.forEach(s => {
                            const mag = Math.sqrt(parseFloat(s.pc1Contrib) ** 2 + parseFloat(s.pc2Contrib) ** 2);
                            if (mag > maxMag) maxMag = mag;
                        });
                        const vectorScale = maxMag > 0 ? 18 / maxMag : 1;
                        const netVectorScale = totalMag > 0 ? 35 / totalMag : 1; // Larger for net vector

                        // Calculate alignment for each song (dot product with total vector)
                        songContributions.forEach(s => {
                            const pc1 = parseFloat(s.pc1Contrib);
                            const pc2 = parseFloat(s.pc2Contrib);
                            const mag = Math.sqrt(pc1 ** 2 + pc2 ** 2);
                            if (mag > 0.001 && totalMag > 0.001) {
                                // Dot product normalized = cos(angle between vectors)
                                const dotProduct = (pc1 * totalPC1 + pc2 * totalPC2) / (mag * totalMag);
                                s.alignment = dotProduct; // -1 to 1
                                s.percentContrib = ((mag / totalMag) * 100).toFixed(1);
                            } else {
                                s.alignment = 0;
                                s.percentContrib = '0.0';
                            }
                        });

                        // Helper to create mini vector SVG with alignment-based color (red→yellow→green gradient)
                        let gradientId = 0;
                        const makeVectorSVG = (pc1, pc2, alignment = 0) => {
                            const x1 = 20, y1 = 20;
                            const dx = parseFloat(pc1) * vectorScale;
                            const dy = parseFloat(pc2) * vectorScale; // No inversion - matches constellation map
                            const mag = Math.sqrt(dx * dx + dy * dy);
                            const gid = `vg${gradientId++}`;

                            if (mag < 0.5) {
                                return `<svg width="40" height="40" style="vertical-align:middle;">
                                    <circle cx="20" cy="20" r="3" fill="rgba(255,255,255,0.2)"/>
                                </svg>`;
                            }

                            const x2 = x1 + dx;
                            const y2 = y1 + dy;

                            const angle = Math.atan2(dy, dx);
                            const headLen = Math.min(6, mag * 0.4);
                            const ax1 = x2 - headLen * Math.cos(angle - 0.5);
                            const ay1 = y2 - headLen * Math.sin(angle - 0.5);
                            const ax2 = x2 - headLen * Math.cos(angle + 0.5);
                            const ay2 = y2 - headLen * Math.sin(angle + 0.5);

                            // Continuous color gradient: red(-1) → yellow(0) → green(+1)
                            // Use exponent to make colors more dramatic
                            const adjustedAlign = Math.sign(alignment) * Math.pow(Math.abs(alignment), 0.6);
                            let r, g, b;
                            if (adjustedAlign >= 0) {
                                // 0 to 1: yellow to green
                                r = Math.round(255 * (1 - adjustedAlign));
                                g = Math.round(180 + 75 * adjustedAlign);
                                b = Math.round(60 * (1 - adjustedAlign));
                            } else {
                                // -1 to 0: red to yellow
                                r = 255;
                                g = Math.round(180 * (1 + adjustedAlign));
                                b = Math.round(60 * (1 + adjustedAlign));
                            }
                            const color = `rgba(${r}, ${g}, ${b}, 0.95)`;

                            return `<svg width="40" height="40" style="vertical-align:middle;">
                                <circle cx="20" cy="20" r="18" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1"/>
                                <line x1="${x1}" y1="${y1}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" stroke="${color}" stroke-width="2.5" stroke-linecap="round"/>
                                <polygon points="${x2.toFixed(1)},${y2.toFixed(1)} ${ax1.toFixed(1)},${ay1.toFixed(1)} ${ax2.toFixed(1)},${ay2.toFixed(1)}" fill="${color}"/>
                            </svg>`;
                        };

                        // Create net vector SVG (larger) with gradient
                        const makeNetVectorSVG = () => {
                            const cx = 50, cy = 50;
                            const dx = totalPC1 * netVectorScale;
                            const dy = totalPC2 * netVectorScale; // No inversion - matches constellation map
                            const x2 = cx + dx;
                            const y2 = cy + dy;

                            const angle = Math.atan2(dy, dx);
                            const headLen = 10;
                            const ax1 = x2 - headLen * Math.cos(angle - 0.4);
                            const ay1 = y2 - headLen * Math.sin(angle - 0.4);
                            const ax2 = x2 - headLen * Math.cos(angle + 0.4);
                            const ay2 = y2 - headLen * Math.sin(angle + 0.4);

                            return `<svg width="100" height="100" style="display:block; margin:auto;">
                                <defs>
                                    <linearGradient id="netGrad" x1="${cx}" y1="${cy}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" gradientUnits="userSpaceOnUse">
                                        <stop offset="0%" stop-color="rgba(219, 97, 162, 0.2)"/>
                                        <stop offset="60%" stop-color="rgba(219, 97, 162, 0.8)"/>
                                        <stop offset="100%" stop-color="rgba(255, 130, 200, 1)"/>
                                    </linearGradient>
                                </defs>
                                <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
                                <circle cx="50" cy="50" r="30" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="1"/>
                                <line x1="5" y1="50" x2="95" y2="50" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
                                <line x1="50" y1="5" x2="50" y2="95" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>
                                <line x1="${cx}" y1="${cy}" x2="${x2.toFixed(1)}" y2="${y2.toFixed(1)}" stroke="url(#netGrad)" stroke-width="4" stroke-linecap="round"/>
                                <polygon points="${x2.toFixed(1)},${y2.toFixed(1)} ${ax1.toFixed(1)},${ay1.toFixed(1)} ${ax2.toFixed(1)},${ay2.toFixed(1)}" fill="rgba(255, 130, 200, 1)"/>
                                <text x="95" y="53" fill="rgba(255,255,255,0.4)" font-size="8" text-anchor="end">+PC1</text>
                                <text x="50" y="95" fill="rgba(255,255,255,0.4)" font-size="8" text-anchor="middle">+PC2</text>
                            </svg>`;
                        };

                        songContributionHTML = `
                            <div style="margin-top:25px; border-top:2px solid var(--pink); padding-top:20px;">
                                <h4 style="font-size:14px; color:var(--pink); margin-bottom:10px;">
                                    Per-Song Contribution Analysis
                                    <span style="font-size:10px; color:var(--muted); font-weight:400; margin-left:8px;">(Advanced Mode)</span>
                                </h4>
                                
                                <!-- Net Effect Summary -->
                                <div style="display:grid; grid-template-columns:100px 1fr; gap:15px; margin-bottom:20px; padding:15px; background:rgba(219,97,162,0.1); border-radius:8px; border:1px solid rgba(219,97,162,0.3);">
                                    <div>${makeNetVectorSVG()}</div>
                                    <div style="display:flex; flex-direction:column; justify-content:center;">
                                        <div style="font-size:12px; font-weight:700; color:var(--pink); margin-bottom:8px;">Net Effect Vector</div>
                                        <div style="font-size:11px; color:var(--muted); line-height:1.6;">
                                            This is the <b>sum of all song vectors</b> - your final position.<br>
                                            <span style="color:var(--green);">● Green arrows</span> align with this direction (reinforce position)<br>
                                            <span style="color:var(--red);">● Red arrows</span> oppose this direction (counteract/negate)<br>
                                            <span style="color:var(--pink);">● Pink arrows</span> are perpendicular (contribute to a different axis)
                                        </div>
                                        <div style="margin-top:10px; font-size:10px; font-family:monospace; color:var(--muted);">
                                            Net: PC1=${totalPC1.toFixed(2)}, PC2=${totalPC2.toFixed(2)} | Magnitude=${totalMag.toFixed(2)}
                                        </div>
                                    </div>
                                </div>
                                
                                <div style="font-size:11px; color:var(--muted); margin-bottom:12px; line-height:1.5;">
                                    Songs sorted by total impact. <b>%</b> shows contribution to final magnitude.
                                </div>
                                <div style="max-height:350px; overflow-y:auto;">
                                    <table style="width:100%; font-size:11px;">
                                        <thead>
                                            <tr style="position:sticky; top:0; background:var(--bg); border-bottom:2px solid var(--border);">
                                                <th style="text-align:center; padding:8px 4px; width:50px;">Vector</th>
                                                <th style="text-align:left; padding:8px 4px;">Song</th>
                                                <th style="text-align:center; padding:8px 4px; width:45px;">%</th>
                                                <th style="text-align:center; padding:8px 4px;">Dev</th>
                                                <th style="text-align:center; padding:8px 4px;">→PC1</th>
                                                <th style="text-align:center; padding:8px 4px;">→PC2</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${songContributions.map(s => {
                            const alignLabel = s.alignment > 0.5 ? '↑' : (s.alignment < -0.5 ? '↓' : '→');
                            const alignColor = s.alignment > 0.5 ? 'var(--green)' : (s.alignment < -0.5 ? 'var(--red)' : 'var(--muted)');
                            return `
                                                <tr style="border-bottom:1px solid rgba(255,255,255,0.05);">
                                                    <td style="text-align:center; padding:2px;">${makeVectorSVG(s.pc1Contrib, s.pc2Contrib, s.alignment)}</td>
                                                    <td style="padding:6px 4px; max-width:160px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${s.name}</td>
                                                    <td style="text-align:center; padding:6px 4px; font-weight:700; color:${parseFloat(s.percentContrib) > 10 ? 'var(--pink)' : 'var(--muted)'};">
                                                        ${s.percentContrib}%
                                                    </td>
                                                    <td style="text-align:center; padding:6px 4px; color:${parseFloat(s.deviation) > 0 ? 'var(--red)' : 'var(--green)'}; font-weight:600;">
                                                        ${parseFloat(s.deviation) > 0 ? '+' : ''}${s.deviation}
                                                    </td>
                                                    <td style="text-align:center; padding:6px 4px; color:${Math.abs(parseFloat(s.pc1Contrib)) > 0.1 ? 'var(--pink)' : 'var(--muted)'}; font-family:monospace;">
                                                        ${parseFloat(s.pc1Contrib) > 0 ? '+' : ''}${s.pc1Contrib}
                                                    </td>
                                                    <td style="text-align:center; padding:6px 4px; color:${Math.abs(parseFloat(s.pc2Contrib)) > 0.1 ? 'var(--pink)' : 'var(--muted)'}; font-family:monospace;">
                                                        ${parseFloat(s.pc2Contrib) > 0 ? '+' : ''}${s.pc2Contrib}
                                                    </td>
                                                </tr>
                                            `}).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                <div style="margin-top:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:6px; font-size:10px; color:var(--muted); line-height:1.5;">
                                    <b>Reading the table:</b><br>
                                    • <b>Vector</b>: Arrow colored by alignment (🟢aligned / 🔴opposing / 🩷perpendicular to net)<br>
                                    • <b>%</b>: This song's contribution to total position magnitude<br>
                                    • <b>Dev</b>: Deviation from average rank (Red = ranked lower, Green = ranked higher)
                                </div>
                            </div>
                        `;
                    } else {
                        songContributionHTML = `<div style="padding:20px; text-align:center; color:var(--muted);">No rank data available for this user to calculate contributions.</div>`;
                    }
                } else {
                    songContributionHTML = `<div style="padding:20px; text-align:center; color:var(--muted);">Song contribution data not available. Rankings or axis data may be loading.</div>`;
                }

                content.innerHTML = `
                    <div style="margin-bottom:20px;">
                        <h4 style="font-size:14px; color:var(--pink); margin-bottom:10px;">Coordinates in Taste Space</h4>
                        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px;">
                            <div class="card" style="padding:12px; text-align:center;">
                                <div style="font-size:10px; color:var(--muted); margin-bottom:5px;">PC1 (X-Axis)</div>
                                <div style="font-size:18px; font-weight:900; color:${node.pc1 > 0 ? 'var(--green)' : 'var(--red)'}">
                                    ${node.pc1 > 0 ? '+' : ''}${node.pc1.toFixed(3)}
                                </div>
                            </div>
                            <div class="card" style="padding:12px; text-align:center;">
                                <div style="font-size:10px; color:var(--muted); margin-bottom:5px;">PC2 (Y-Axis)</div>
                                <div style="font-size:18px; font-weight:900; color:${node.pc2 > 0 ? 'var(--green)' : 'var(--red)'}">
                                    ${node.pc2 > 0 ? '+' : ''}${node.pc2.toFixed(3)}
                                </div>
                            </div>
                            <div class="card" style="padding:12px; text-align:center;">
                                <div style="font-size:10px; color:var(--muted); margin-bottom:5px;">PC3 (Z-Depth)</div>
                                <div style="font-size:18px; font-weight:900; color:${node.pc3 > 0 ? 'var(--green)' : 'var(--red)'}">
                                    ${node.pc3 > 0 ? '+' : ''}${node.pc3.toFixed(3)}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="margin-bottom:20px;">
                        <h4 style="font-size:14px; color:var(--pink); margin-bottom:10px;">Distance from Consensus</h4>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                            <div class="card" style="padding:12px; background:rgba(219,97,162,0.1); border-color:var(--pink);">
                                <div style="font-size:10px; color:var(--muted); margin-bottom:5px;">2D Distance (Visible)</div>
                                <div style="font-size:22px; font-weight:900; color:var(--pink)">${distance2D}</div>
                                <div style="font-size:9px; color:var(--muted); margin-top:3px;">Euclidean distance in 2D projection</div>
                            </div>
                            <div class="card" style="padding:12px;">
                                <div style="font-size:10px; color:var(--muted); margin-bottom:5px;">3D Distance (True)</div>
                                <div style="font-size:22px; font-weight:900;">${distance}</div>
                                <div style="font-size:9px; color:var(--muted); margin-top:3px;">Full dimensional distance</div>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h4 style="font-size:14px; color:var(--pink); margin-bottom:10px;">Interpretation</h4>
                        <div style="font-size:12px; color:var(--muted); line-height:1.6; padding:12px; background:rgba(255,255,255,0.03); border-radius:6px;">
                            <p style="margin:0 0 8px 0;">The <b>coordinates</b> show where <b>${node.id}</b> sits in the multi-dimensional taste space.</p>
                            <ul style="margin:0; padding-left:20px;">
                                <li><b>PC1 (${node.pc1 > 0 ? 'Positive' : 'Negative'})</b>: Aligns with ${node.pc1 > 0 ? 'right' : 'left'} side of the X-axis spectrum</li>
                                <li><b>PC2 (${node.pc2 > 0 ? 'Positive' : 'Negative'})</b>: Aligns with ${node.pc2 > 0 ? 'top' : 'bottom'} side of the Y-axis spectrum</li>
                                <li><b>Distance</b>: ${distance2D > 0.5 ? 'High divergence - unique taste profile' : 'Low divergence - mainstream taste'}</li>
                            </ul>
                        </div>
                    </div>
                    
                    ${songContributionHTML}
                `;
            }

            // Show picker when nodes overlap
            window.showNodePicker = function (nodes, x, y) {
                const modal = document.getElementById('song-modal');
                const content = document.getElementById('song-modal-content');
                const title = document.getElementById('song-modal-title');

                title.textContent = 'Select User';
                modal.classList.remove('hidden');
                modal.style.display = 'flex';

                // Store nodes globally for onclick access
                window.tempOverlapNodes = nodes;

                content.innerHTML = `
                    <div style="font-size:12px; color:var(--muted); margin-bottom:15px; text-align:center;">
                        Multiple users are in this area. Select one to view position details:
                    </div>
                    <div style="display:grid; gap:10px;">
                        ${nodes.map((n, idx) => `
                            <div onclick="showUserPositionMath(window.tempOverlapNodes[${idx}]);"  
                                 style="padding:15px; background:var(--card); border:1px solid var(--border); border-radius:8px; cursor:pointer; transition:all 0.2s;"
                                 onmouseover="this.style.borderColor='var(--pink)'; this.style.background='rgba(219,97,162,0.1)'"
                                 onmouseout="this.style.borderColor='var(--border)'; this.style.background='var(--card)'">
                                <div style="display:flex; align-items:center; gap:12px;">
                                    <div style="width:32px; height:32px; border-radius:50%; background:${n.color}; display:flex; align-items:center; justify-content:center; font-weight:bold; color:#000; font-size:14px;">
                                        ${n.initials}
                                    </div>
                                    <div style="font-weight:600; font-size:16px;">${n.id}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }


            // Find top polarizing songs for each axis (keep for reference)
            graphPC1Songs = window.graphAxisData.pc1.slice(0, 3).map(s => s.name);
            graphPC2Songs = window.graphAxisData.pc2.slice(0, 3).map(s => s.name);

            // No edges needed (user requested removal)

            // Events
            // Drag State
            window.graphIsDragging = false;
            window.graphLastMouseX = 0;
            window.graphAutoRotate = true;

            cvs.onmousedown = e => {
                if (window.graphIs3D) {
                    window.graphIsDragging = true;
                    window.graphLastMouseX = e.clientX;
                    window.graphAutoRotate = false;
                    cvs.style.cursor = 'grabbing';
                }
            };
            cvs.onmouseup = e => {
                window.graphIsDragging = false;
                if (window.graphIs3D) cvs.style.cursor = 'grab';
            };
            cvs.onmouseleave = cvs.onmouseup;

            // Events
            cvs.onmousemove = e => {
                const r = cvs.getBoundingClientRect();
                const mx = e.clientX - r.left, my = e.clientY - r.top;

                // 3D Logic
                if (window.graphIs3D) {
                    if (window.graphIsDragging) {
                        const delta = e.clientX - window.graphLastMouseX;
                        window.graphRotation += delta * 0.005;
                        window.graphLastMouseX = e.clientX;
                        return; // Don't do hover logic while dragging
                    } else {
                        cvs.style.cursor = 'grab';
                    }

                    // 3D Hit Testing
                    const searchNodes = window.graphProjectedNodes || [];
                    const minDst = 20;

                    // Filter hits
                    const hits = searchNodes.filter(n => {
                        if (!n.scale || n.scale <= 0) return false;
                        return Math.hypot(n.x2d - mx, n.y2d - my) < minDst;
                    });

                    // Pick closest to camera (largest scale)
                    if (hits.length > 0) {
                        hits.sort((a, b) => b.scale - a.scale);
                        graphHover = hits[0];
                        cvs.style.cursor = 'pointer';
                    } else {
                        graphHover = null;
                        cvs.style.cursor = window.graphIsDragging ? 'grabbing' : 'grab';
                    }
                    return;
                }

                // Node Hover
                graphHover = graphNodes.find(n => Math.hypot(n.x - mx, n.y - my) < 12);

                // Axis Hover (REDUCED to match click areas)
                const w = cvs.width, h = cvs.height, cx = w / 2, cy = h / 2;
                window.graphHoverLabel = null;
                if (mx > w - 120 && Math.abs(my - cy) < 25) window.graphHoverLabel = 'x';
                else if (Math.abs(mx - cx) < 100 && my < 35) window.graphHoverLabel = 'y';

                // Cursor
                cvs.style.cursor = (graphHover || window.graphHoverLabel) ? 'pointer' : 'default';

                if (typeof drawGraph === 'function') drawGraph();
            };

            if (typeof drawGraph === 'function') drawGraph();
        }

        // Dashboard Constellation (simplified 2D version)
        function initDashboardConstellation(data) {
            const matrixData = data.matrix;
            const cvs = document.getElementById('dash-taste-canvas');
            if (!cvs || !matrixData) return;
            const rect = cvs.getBoundingClientRect();
            cvs.width = rect.width; cvs.height = rect.height;
            const ctx = cvs.getContext('2d');

            const users = Object.keys(matrixData);
            const distMatrix = users.map(u1 => users.map(u2 => matrixData[u1][u2]));
            const { coords } = MathLib.mds(distMatrix);

            const w = cvs.width, h = cvs.height;
            const scale = Math.min(w, h) * 0.35;
            const nodes = users.map((u, i) => ({
                id: u,
                x: coords[i].x * scale + w / 2,
                y: coords[i].y * scale + h / 2,
                color: `hsl(${280 + ((i * 40) % 80)}, 70%, 60%)`
            }));

            // Simple draw
            ctx.clearRect(0, 0, w, h);
            nodes.forEach(n => {
                ctx.fillStyle = n.color;
                ctx.beginPath();
                ctx.arc(n.x, n.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(n.id, n.x, n.y + 18);
            });
        }

        function drawGraph() {
            if (!graphCtx || window.graphIs3D) return;
            const cvs = document.getElementById('taste-canvas');
            const w = cvs.width, h = cvs.height;

            graphCtx.clearRect(0, 0, w, h);

            // Background Structure (to make it look less random)
            const cx = w / 2, cy = h / 2;

            graphCtx.save();
            graphCtx.strokeStyle = 'rgba(219, 97, 162, 0.1)'; // Theme pink, very faint
            graphCtx.lineWidth = 1;
            graphCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            graphCtx.font = '9px Inter, monospace';
            graphCtx.textAlign = 'center';
            graphCtx.textBaseline = 'middle';

            // Find max PC value for grid scaling (use raw PC coords, not pixels)
            let maxPCDist = 0;
            graphNodes.forEach(n => {
                maxPCDist = Math.max(maxPCDist, Math.abs(n.pc1), Math.abs(n.pc2));
            });

            // Choose nice grid step based on max PC value
            const scale = window.graphScale || 1;
            let pcGridStep;
            if (maxPCDist <= 0.5) pcGridStep = 0.1;
            else if (maxPCDist <= 1) pcGridStep = 0.25;
            else if (maxPCDist <= 2) pcGridStep = 0.5;
            else if (maxPCDist <= 5) pcGridStep = 1;
            else pcGridStep = Math.ceil(maxPCDist / 4);

            // Calculate the maximum visible radius in PC units (to canvas edge)
            const maxVisibleRadius = Math.max(w, h) / 2 / scale;
            const maxGridPC = Math.ceil(maxVisibleRadius / pcGridStep) * pcGridStep;

            // Concentric circles with PC value labels - continue to canvas edges
            for (let pcVal = pcGridStep; pcVal <= maxGridPC; pcVal += pcGridStep) {
                const pixelRadius = pcVal * scale;
                graphCtx.beginPath();
                graphCtx.arc(cx, cy, pixelRadius, 0, Math.PI * 2);
                graphCtx.stroke();
                // Axis labels showing actual PC values (only show labels within visible area)
                if (pixelRadius < Math.min(w, h) / 2 - 20) {
                    const label = pcVal % 1 === 0 ? pcVal.toString() : pcVal.toFixed(1);
                    graphCtx.fillText(label, cx + pixelRadius + 5, cy);
                    graphCtx.fillText('-' + label, cx - pixelRadius - 5, cy);
                }
            }

            // Draw Theoretical Limit Ring (dashed pink outer boundary)
            if (window.theoMax && window.theoMax > 0) {
                const limitRadius = window.theoMax * scale;
                graphCtx.strokeStyle = 'rgba(219, 97, 162, 0.5)'; // Pink
                graphCtx.setLineDash([6, 4]); // Dashed
                graphCtx.lineWidth = 2;
                graphCtx.beginPath();
                graphCtx.arc(cx, cy, limitRadius, 0, Math.PI * 2);
                graphCtx.stroke();
                graphCtx.setLineDash([]); // Reset
                graphCtx.lineWidth = 1;

                // Label for Theoretical Limit
                graphCtx.fillStyle = 'rgba(219, 97, 162, 0.8)';
                graphCtx.font = 'bold 10px Inter';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'bottom';
                graphCtx.fillText("Theoretical Limit", cx, cy - limitRadius - 4);
                graphCtx.textBaseline = 'middle';
            }

            // Crosshairs with Labels
            graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            graphCtx.beginPath(); graphCtx.moveTo(0, cy); graphCtx.lineTo(w, cy); graphCtx.stroke();
            graphCtx.beginPath(); graphCtx.moveTo(cx, 0); graphCtx.lineTo(cx, h); graphCtx.stroke();

            // Axis Labels (with Defining Songs)
            // Axis Labels (with Defining Songs)
            graphCtx.font = 'italic 10px Inter, sans-serif';

            // X-Axis
            graphCtx.textAlign = 'right';
            const pc1Label = window.graphAxisLabels ? window.graphAxisLabels.x : (graphPC1Songs.length ? `X: Polarized by "${graphPC1Songs[0]}"` : "X: Primary Variance");
            graphCtx.fillStyle = (window.graphHoverLabel === 'x') ? '#fff' : 'rgba(255, 255, 255, 0.4)';
            graphCtx.fillText(pc1Label, w - 10, cy - 6);
            if (window.graphHoverLabel === 'x') {
                const m = graphCtx.measureText(pc1Label);
                graphCtx.fillRect(w - 10 - m.width, cy - 4, m.width, 1);
            }

            // Y-Axis
            graphCtx.textAlign = 'center';
            const pc2Label = window.graphAxisLabels ? window.graphAxisLabels.y : (graphPC2Songs.length ? `Y: Polarized by "${graphPC2Songs[0]}"` : "Y: Secondary Variance");
            graphCtx.fillStyle = (window.graphHoverLabel === 'y') ? '#fff' : 'rgba(255, 255, 255, 0.4)';
            graphCtx.fillText(pc2Label, cx, 20);
            if (window.graphHoverLabel === 'y') {
                const m = graphCtx.measureText(pc2Label);
                graphCtx.fillRect(cx - m.width / 2, 22, m.width, 1);
            }

            // Origin Label
            graphCtx.textAlign = 'center';
            graphCtx.fillText("0", cx + 5, cy + 10);

            // Legend / Explanation
            graphCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            graphCtx.font = 'bold 12px Inter, sans-serif';
            graphCtx.textAlign = 'left'; graphCtx.textBaseline = 'bottom';
            graphCtx.fillText("TASTE CONSTELLATION (Multidimensional Scaling)", 20, h - 75);

            graphCtx.font = '10px Inter, sans-serif'; graphCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            graphCtx.fillText("• Center (0,0): Community Consensus (Average Taste)", 20, h - 55);
            graphCtx.fillText("• Distance: RMS Taste Divergence (Length of difference vector)", 20, h - 40);
            graphCtx.fillText("• Projection: Top 2 Principal Components (PC1 & PC2) of variance", 20, h - 25);
            graphCtx.fillText(`• 2D Accuracy: ${graphVarianceExplained}% (captures nearly all structure)`, 20, h - 10);

            // Interaction instruction
            if (window.constellationSelectedUser) {
                graphCtx.fillStyle = 'rgba(219, 97, 162, 0.8)';
                graphCtx.font = 'bold 11px Inter';
                graphCtx.fillText(`✓ ${window.constellationSelectedUser} selected - Click another user to compare`, 20, 20);
            } else {
                graphCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                graphCtx.font = '10px Inter';
                graphCtx.fillText("Click any user to select, then click another to compare divergence", 20, 20);
            }

            graphCtx.restore();

            // No Edges (removed per user feedback)

            // Nodes (smaller for less overlap)
            graphNodes.forEach(n => {
                graphCtx.shadowBlur = 0;

                // Border
                graphCtx.fillStyle = '#161b22';
                graphCtx.beginPath(); graphCtx.arc(n.x, n.y, 12, 0, Math.PI * 2); graphCtx.fill();
                // Color
                graphCtx.fillStyle = n.color;
                graphCtx.beginPath(); graphCtx.arc(n.x, n.y, 10, 0, Math.PI * 2); graphCtx.fill();

                // Label (Full Name) - draw below the node
                graphCtx.fillStyle = "rgba(255, 255, 255, 0.8)";
                graphCtx.font = "bold 9px Inter, sans-serif";
                graphCtx.textAlign = "center"; graphCtx.textBaseline = "top";
                graphCtx.fillText(n.id, n.x, n.y + 14);

                // Hover glow
                if (graphHover === n) {
                    graphCtx.shadowBlur = 15; graphCtx.shadowColor = n.color;
                }
            });
        }

        // 3D Visualizer Logic
        window.graphIs3D = window.graphIs3D || false;
        window.graphRotation = window.graphRotation || 0;
        var graphAnimFrame = graphAnimFrame || null;

        window.toggle3D = () => {
            window.graphIs3D = !window.graphIs3D;
            const btn = document.getElementById('toggle-3d');
            const cvs = document.getElementById('taste-canvas');
            if (window.graphIs3D) {
                btn.innerHTML = "SWITCH TO 2D";
                btn.style.background = "var(--pink)";
                btn.style.color = "#000";
                document.getElementById('constellation-mode-text').textContent = "3D space";
                // Start Loop
                window.graphRotation = 0;
                if (graphAnimFrame) cancelAnimationFrame(graphAnimFrame);
                animate3D();
            } else {
                btn.innerHTML = "SWITCH TO 3D";
                btn.style.background = "transparent";
                btn.style.color = "var(--pink)";
                document.getElementById('constellation-mode-text').textContent = "2D space";
                if (graphAnimFrame) cancelAnimationFrame(graphAnimFrame);
                drawGraph(); // Draw 2D
                cvs.style.cursor = 'default';
            }
        };

        function animate3D() {
            if (!window.graphIs3D) return;
            if (window.graphAutoRotate) {
                window.graphRotation += 0.005;
            }
            drawGraph3D();
            graphAnimFrame = requestAnimationFrame(animate3D);
        }

        window.drawGraph3D = () => {
            if (!graphCtx) return;
            const cvs = document.getElementById('taste-canvas');
            const w = cvs.width, h = cvs.height;
            const cx = w / 2, cy = h / 2;

            graphCtx.clearRect(0, 0, w, h);

            // 3D Config
            const fov = 500;
            const cameraZ = 600;
            const cos = Math.cos(window.graphRotation);
            const sin = Math.sin(window.graphRotation);

            // Project Helper
            const project = (x, y, z) => {
                const x3 = x * cos - z * sin;
                const y3 = y;
                const z3 = x * sin + z * cos;
                const depth = z3;
                const dist = cameraZ - depth;
                if (dist <= 0) return null;
                const scale = fov / dist;
                return { x: x3 * scale + cx, y: y3 * scale + cy, scale, depth };
            };

            // Draw Title
            graphCtx.fillStyle = 'rgba(255,255,255,0.5)';
            graphCtx.font = '12px Inter';
            graphCtx.textAlign = 'left'; graphCtx.textBaseline = 'top';
            const title = window.graphAutoRotate ? "3D Mode - Auto-Rotating" : "3D Mode - Drag to Rotate";
            graphCtx.fillText(title, 20, 20);

            // Draw Axes
            const axisLen = 300;
            const axes = [
                { s: [-axisLen, 0, 0], e: [axisLen, 0, 0], c: '#ff4444', l: 'X' },
                { s: [0, -axisLen, 0], e: [0, axisLen, 0], c: '#44ff44', l: 'Y' },
                { s: [0, 0, -axisLen], e: [0, 0, axisLen], c: '#4488ff', l: 'Z' }
            ];

            axes.forEach(ax => {
                const p1 = project(...ax.s);
                const p2 = project(...ax.e);
                if (p1 && p2) {
                    graphCtx.beginPath();
                    graphCtx.strokeStyle = ax.c;
                    graphCtx.lineWidth = 1; graphCtx.globalAlpha = 0.5;
                    graphCtx.moveTo(p1.x, p1.y);
                    graphCtx.lineTo(p2.x, p2.y);
                    graphCtx.stroke();
                    graphCtx.globalAlpha = 1;
                    // Label
                    graphCtx.fillStyle = ax.c;
                    graphCtx.font = 'bold 12px Inter';
                    graphCtx.textAlign = 'center';
                    graphCtx.fillText(ax.l, p2.x, p2.y);
                }
            });

            // Project Nodes
            const projected = graphNodes.map(n => {
                const p = project(n.realX, n.realY, n.realZ);
                return p ? { ...n, x2d: p.x, y2d: p.y, scale: p.scale, depth: p.depth } : { ...n, scale: 0 };
            });

            // Make projected nodes available for hit-testing
            window.graphProjectedNodes = projected;

            // Sort: draw furthest first
            projected.sort((a, b) => a.scale - b.scale);

            projected.forEach(n => {
                if (n.scale <= 0) return;

                const isHovered = (graphHover === n);
                // Boost size for closer nodes, and even more for hovered nodes
                const baseSize = 10;
                let size = Math.max(2, baseSize * n.scale);
                if (isHovered) size *= 1.3;

                // Opacity based on depth
                graphCtx.globalAlpha = Math.min(1, Math.max(0.15, n.scale * 1.2));

                // 1. Glow (if hovered)
                if (isHovered) {
                    graphCtx.shadowBlur = 15;
                    graphCtx.shadowColor = n.color;
                    graphCtx.globalAlpha = 1; // Full opacity if hovered
                } else {
                    graphCtx.shadowBlur = 0;
                }

                // 2. Border (Dark background circle)
                graphCtx.fillStyle = '#161b22';
                graphCtx.beginPath();
                graphCtx.arc(n.x2d, n.y2d, size + 2, 0, Math.PI * 2);
                graphCtx.fill();

                // 3. Inner Color
                graphCtx.fillStyle = n.color;
                graphCtx.beginPath();
                graphCtx.arc(n.x2d, n.y2d, size, 0, Math.PI * 2);
                graphCtx.fill();

                // 4. Label
                // Show if hovered OR if node is relatively close (scale > 0.6)
                if (isHovered || n.scale > 0.7) {
                    graphCtx.fillStyle = isHovered ? '#fff' : 'rgba(255, 255, 255, 0.85)';
                    const fontSize = Math.max(9, 11 * n.scale);

                    graphCtx.font = `${isHovered ? 'bold' : '500'} ${fontSize}px Inter, sans-serif`;
                    graphCtx.textAlign = 'center';

                    // Full name if hovered, otherwise just initials? 
                    // Let's stick to ID (Full Name) but fade it
                    graphCtx.fillText(n.id, n.x2d, n.y2d + size + 5 + fontSize);
                }

                graphCtx.globalAlpha = 1;
                graphCtx.shadowBlur = 0;
            });
        };


        function toggleSubmission(show) { document.getElementById('submission-overlay').style.display = show ? 'flex' : 'none'; }

        // UPDATED SUBMISSION LOGIC
        async function postSubmission() {
            const log = document.getElementById('submit-log');
            const user = document.getElementById('in-user').value.trim();
            const list = document.getElementById('in-list').value.trim();
            const f = document.getElementById('sub-franchise').value;
            const btn = document.getElementById('submit-btn-real');

            // Validation: Ensure fields are non-empty
            if (!user || !list) {
                log.innerHTML = `<span style="color:var(--red)">Username and list are required.</span>`;
                return;
            }

            btn.disabled = true;
            log.innerHTML = "POSTING DATA...";

            try {
                const r = await fetch(`${API}/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: user,
                        franchise: f,
                        subgroup_name: "All Songs",
                        ranking_list: list
                    })
                });
                const d = await r.json();
                if (d.status === "VALID") {
                    log.innerHTML = `<span style="color:var(--green)">SUCCESSFULLY SUBMITTED!</span>`;
                    setTimeout(() => {
                        toggleSubmission(false);
                        btn.disabled = false;
                    }, 1500);
                } else {
                    let firstErr = Object.values(d.conflicts)[0];
                    log.innerHTML = `<span style="color:var(--red)">VALIDATION ERROR: Line ${firstErr.line_num} (${firstErr.reason})</span>`;
                    btn.disabled = false;
                }
            } catch (e) {
                log.innerHTML = `<span style="color:var(--red)">CONNECTION ERROR.</span>`;
                btn.disabled = false;
            }
        }

        function initDashboardConstellation(data) {
            // data = { matrix: {...}, rankings: {...}, song_names: {...} }
            const cvs = document.getElementById('dash-taste-canvas');
            if (!cvs || !data.matrix) return;
            const ctx = cvs.getContext('2d');

            // Set canvas size
            const rect = cvs.getBoundingClientRect();
            cvs.width = rect.width; cvs.height = rect.height;
            const w = cvs.width, h = cvs.height;
            const cx = w / 2, cy = h / 2;

            const users = Object.keys(data.matrix);
            if (users.length < 3) {
                ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.fillText("Not enough users", cx, cy); return;
            }

            const distMatrix = users.map(u1 => users.map(u2 => data.matrix[u1][u2]));
            let mdsResult;
            try { mdsResult = MathLib.mds(distMatrix); } catch (e) { return; }

            const coords = mdsResult.coords; // {x,y,z}

            // --- AUTO ZOOM LOGIC ---
            // 1. Find bounding box of all points relative to center 0,0
            let maxX = 0, maxY = 0;
            coords.forEach(p => {
                maxX = Math.max(maxX, Math.abs(p.x));
                maxY = Math.max(maxY, Math.abs(p.y));
            });

            // 2. Calculate scale to fill ~90% of the smallest dimension
            // padding = 20px
            const padding = 30;
            const safeW = (w / 2) - padding;
            const safeH = (h / 2) - padding;

            // If all points are at 0,0 (perfect consensus), default scale 1
            const scaleX = maxX > 0 ? safeW / maxX : 1;
            const scaleY = maxY > 0 ? safeH / maxY : 1;

            // Use the smaller scale to maintain aspect ratio and fit everything
            const scale = Math.min(scaleX, scaleY);

            // --- DRAW ---
            ctx.clearRect(0, 0, w, h);

            // Grid rings (simple)
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.beginPath(); ctx.arc(cx, cy, 50, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, 100, 0, Math.PI * 2); ctx.stroke();

            // Axis lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();

            // Nodes
            const nodes = users.map((u, i) => ({
                id: u,
                x: coords[i].x * scale + cx,
                y: coords[i].y * scale + cy,
                color: `hsl(${280 + ((i * 40) % 80)}, 70%, 60%)`,
                initials: u.substring(0, 2).toUpperCase()
            }));

            // Draw furthest first if we had 3D Z-depth, but for 2D standard draw is fine
            nodes.forEach(n => {
                ctx.fillStyle = n.color;
                ctx.beginPath(); ctx.arc(n.x, n.y, 6, 0, Math.PI * 2); ctx.fill();

                // Initials
                ctx.fillStyle = "#fff";
                ctx.font = "bold 9px Inter";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(n.initials, n.x, n.y + 12);
            });

            // Label
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '10px Inter';
            ctx.textAlign = 'right';
            ctx.fillText("Zoomed View", w - 10, h - 10);
        }

        async function loadUsers() {
            const franchise = document.getElementById('view-franchise').value;
            const subgroup = document.getElementById('view-subgroup').value;
            const content = document.getElementById('users-content');
            const statsContainer = document.getElementById('users-stats-container');

            content.innerHTML = '<div style="text-align: center; padding: 80px 20px; font-size: 18px; color: var(--muted);">Loading rankings...</div>';
            statsContainer.innerHTML = '';

            try {
                const [rankingsRes, spiceRes] = await Promise.all([
                    fetch(`${API}/users/rankings?franchise=${franchise}&subgroup=${encodeURIComponent(subgroup)}`),
                    fetch(`${API}/analysis/spice?franchise=${franchise}`)
                ]);

                if (!rankingsRes.ok) throw new Error(`API returned ${rankingsRes.status}`);

                const data = await rankingsRes.json();
                const spiceData = spiceRes.ok ? await spiceRes.json() : { results: [] };
                const spiceMap = {};
                (spiceData.results || []).forEach(u => spiceMap[u.username] = u.global_spice);

                // Calculate aggregate stats
                const avgSongsRanked = data.users.length > 0
                    ? Math.round(data.users.reduce((a, u) => a + u.total_songs, 0) / data.users.length)
                    : 0;

                // Stats Bar
                statsContainer.innerHTML = `
                    <div class="dashboard-grid" style="margin-bottom: 25px;">
                        <div class="stat-card">
                            <div class="stat-label">Total Users</div>
                            <div class="stat-value">${data.total_users}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Franchise</div>
                            <div class="stat-value">${capitalize(data.franchise)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Avg. Songs Ranked</div>
                            <div class="stat-value">${avgSongsRanked}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Subgroup</div>
                            <div class="stat-value" style="font-size:18px">${subgroup}</div>
                        </div>
                    </div>
                `;

                if (data.users.length === 0) {
                    content.innerHTML = '<div style="text-align: center; padding: 60px 20px; color: var(--muted);"><p>No rankings found for this selection.</p></div>';
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'user-grid';

                data.users.forEach(user => {
                    const card = document.createElement('div');
                    card.className = 'user-card';

                    // Find user's #1 pick
                    const topPick = user.rankings.length > 0 ? user.rankings[0].song_name : 'N/A';

                    // User spice level
                    const spice = spiceMap[user.username] || 'N/A';

                    const rankingsList = user.rankings.map((r, i) => {
                        let rankClass = '';
                        let itemClass = '';
                        if (i === 0) { rankClass = 'gold'; itemClass = 'top-3'; }
                        else if (i === 1) { rankClass = 'silver'; itemClass = 'top-3'; }
                        else if (i === 2) { rankClass = 'bronze'; itemClass = 'top-3'; }

                        const escapedName = r.song_name.replace(/'/g, "\\'");
                        return `
                            <div class="rank-item ${itemClass}" onclick="showSongDistribution('${escapedName}')" style="cursor:pointer;">
                                <div class="rank-number ${rankClass}">#${r.rank}</div>
                                <div class="song-name">${r.song_name}</div>
                            </div>
                        `;
                    }).join('');

                    card.innerHTML = `
                        <div class="user-header">
                            <div class="user-name">${user.username}</div>
                            <div class="song-count">${user.total_songs} songs</div>
                        </div>
                        <div class="user-insights">
                            <div class="insight-item">
                                <div class="insight-label">Top Pick</div>
                                <div class="insight-value green">${truncate(topPick, 20)}</div>
                            </div>
                            <div class="insight-item">
                                <div class="insight-label">Spice Level</div>
                                <div class="insight-value yellow">${spice}</div>
                            </div>
                        </div>
                        <div class="rankings-list">
                            ${rankingsList}
                        </div>
                    `;

                    grid.appendChild(card);
                });

                content.innerHTML = '';
                content.appendChild(grid);

            } catch (error) {
                console.error('Error loading rankings:', error);
                content.innerHTML = `<div style="background: rgba(248, 81, 73, 0.15); border: 1px solid var(--red); color: var(--red); padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center; font-weight: 600;">Failed to load rankings: ${error.message}</div>`;
            }
        }

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        async function recompute() {
            document.getElementById('engine-log').innerText = "CALCULATING...";
            await fetch(`${API}/analysis/trigger`, { method: 'POST' });
            setTimeout(() => { syncData(); document.getElementById('engine-log').innerText = "READY"; }, 3000);
        }

        init();
    </script>
    <!-- Load app.js for complete Tiers tab and other advanced features -->
    <script src="/app.js"></script>
</body>

</html>